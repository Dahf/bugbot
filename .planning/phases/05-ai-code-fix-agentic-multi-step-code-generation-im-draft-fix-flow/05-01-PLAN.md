---
phase: 05-ai-code-fix-agentic-multi-step-code-generation-im-draft-fix-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config.py
  - src/services/github_service.py
autonomous: true
requirements:
  - GH-04
  - GH-05
  - GH-06

must_haves:
  truths:
    - "GitHubService can commit multiple file changes in a single atomic commit via Git Data API"
    - "GitHubService can poll CI check runs and return pass/fail/no_ci/timeout status"
    - "GitHubService can extract an installation access token for git CLI operations"
    - "Config exposes ANTHROPIC_CODE_FIX_MODEL and CODE_FIX_MAX_ROUNDS env vars with sensible defaults"
  artifacts:
    - path: "src/services/github_service.py"
      provides: "Atomic multi-file commit, CI polling, installation token extraction"
      exports: ["commit_files_atomic", "poll_ci_status", "get_installation_token"]
    - path: "src/config.py"
      provides: "Code fix configuration env vars"
      contains: "ANTHROPIC_CODE_FIX_MODEL"
  key_links:
    - from: "src/services/github_service.py"
      to: "githubkit REST git API"
      via: "async_create_blob, async_create_tree, async_create_commit, async_update_ref"
      pattern: "gh\\.rest\\.git\\.async_create"
    - from: "src/services/github_service.py"
      to: "githubkit REST checks API"
      via: "async_list_for_ref"
      pattern: "gh\\.rest\\.checks\\.async_list_for_ref"
---

<objective>
Extend GitHubService with Git Data API methods for atomic multi-file commits and Checks API polling for CI status, and add code fix configuration to Config.

Purpose: Phase 5's agentic code fix needs to (a) commit all generated file changes in a single atomic commit (not one commit per file), (b) check whether CI passes after pushing, and (c) obtain a raw installation token for git clone CLI operations. These are generic GitHub service methods that the CodeFixService (Plan 02) will consume.

Output: Extended `github_service.py` with 3 new methods, extended `config.py` with code fix env vars.
</objective>

<execution_context>
@C:/Users/silas/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/silas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ai-code-fix-agentic-multi-step-code-generation-im-draft-fix-flow/05-RESEARCH.md

@src/services/github_service.py
@src/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add atomic multi-file commit and CI polling methods to GitHubService</name>
  <files>src/services/github_service.py</files>
  <action>
Add three new methods to the GitHubService class:

1. `async def commit_files_atomic(self, owner, repo, branch, changed_files: dict[str, str], commit_message: str) -> str`:
   - Takes a dict of {relative_path: file_content} and commits them all in ONE atomic commit.
   - Implementation steps (per research Pattern 2):
     a. Get installation client
     b. For each file in changed_files, call `gh.rest.git.async_create_blob(owner, repo, content=content, encoding="utf-8")` to create blobs
     c. Get current branch HEAD: `gh.rest.git.async_get_ref(owner, repo, f"heads/{branch}")` -> get object_.sha
     d. Get current commit's tree SHA: `gh.rest.git.async_get_commit(owner, repo, head_sha)` -> get tree.sha
     e. Build tree_items list: `[{"path": p, "mode": "100644", "type": "blob", "sha": blob_sha}]`
     f. Create new tree: `gh.rest.git.async_create_tree(owner, repo, tree=tree_items, base_tree=base_tree_sha)`
     g. Create commit: `gh.rest.git.async_create_commit(owner, repo, tree=new_tree_sha, message=commit_message, parents=[head_sha])`
     h. Update ref: `gh.rest.git.async_update_ref(owner, repo, f"heads/{branch}", sha=new_commit_sha)`
   - Returns the new commit SHA string.
   - Log the commit at INFO level.

2. `async def poll_ci_status(self, owner, repo, ref, timeout=300, poll_interval=15, initial_delay=15) -> dict`:
   - Polls GitHub Checks API until all check runs complete or timeout.
   - Implementation (per research Pattern 3):
     a. Sleep `initial_delay` seconds first (let GitHub Actions register check runs).
     b. Loop until `timeout` elapsed:
        - Call `gh.rest.checks.async_list_for_ref(owner, repo, ref)`
        - If `total_count == 0` and this is the first poll, wait one more interval and retry. If still 0, return `{"status": "no_ci", "details": "No CI pipeline detected"}`.
        - If all check_runs have `status == "completed"`, check conclusions. Failures are any with `conclusion not in ("success", "neutral", "skipped")`.
        - If failures: return `{"status": "failed", "details": "- name: conclusion\n..."}`.
        - If all passed: return `{"status": "passed", "details": f"All {total} checks passed"}`.
        - Otherwise, sleep `poll_interval` and continue.
     c. On timeout: return `{"status": "timeout", "details": f"CI did not complete within {timeout}s"}`
   - Uses `asyncio.sleep` for non-blocking waits.

3. `async def get_installation_token(self, owner, repo) -> str`:
   - Gets a raw installation access token string for git CLI operations (clone, push).
   - Implementation:
     a. Get the installation ID: `resp = await self.app_github.rest.apps.async_get_repo_installation(owner, repo)` -> `installation_id = resp.parsed_data.id`
     b. Create an installation token: `token_resp = await self.app_github.rest.apps.async_create_installation_access_token(installation_id)` -> return `token_resp.parsed_data.token`
   - Note: If the exact API for token creation differs in githubkit, fall back to using the internal auth mechanism. The research notes this as an open question -- test during implementation and adapt as needed.

Add `import asyncio` at the top of the file if not already present (needed for `asyncio.sleep` in poll_ci_status).
  </action>
  <verify>
Run `python -c "from src.services.github_service import GitHubService; print('Import OK')"` to confirm no import errors. Visually inspect that `commit_files_atomic`, `poll_ci_status`, and `get_installation_token` are defined as async methods on the class.
  </verify>
  <done>GitHubService has three new async methods: commit_files_atomic (creates blobs, tree, commit, updates ref), poll_ci_status (polls checks API with timeout), and get_installation_token (returns raw token string). All use the installation client pattern established in Phase 3.</done>
</task>

<task type="auto">
  <name>Task 2: Add code fix configuration to Config</name>
  <files>src/config.py</files>
  <action>
Add new optional configuration fields in `Config.__init__` under a new comment section `# AI Code Fix (Phase 5) -- optional`:

1. `self.ANTHROPIC_CODE_FIX_MODEL: str = os.getenv("ANTHROPIC_CODE_FIX_MODEL", "claude-sonnet-4-5-20250929")`
   - Default to Sonnet for code generation (more capable than Haiku for code, cheaper than Opus). Per research open question #2.

2. `self.CODE_FIX_MAX_ROUNDS: int = int(os.getenv("CODE_FIX_MAX_ROUNDS", "3"))`
   - Maximum iteration rounds before finalizing. Locked decision: 3 rounds max.

3. `self.CODE_FIX_MAX_TOKENS: int = int(os.getenv("CODE_FIX_MAX_TOKENS", "4096"))`
   - Max tokens per Claude API call during code generation. Per research recommendation.

4. `self.CODE_FIX_MAX_FILES: int = int(os.getenv("CODE_FIX_MAX_FILES", "15"))`
   - Max files Claude can read during exploration. Locked decision: cap at 15.

5. `self.CODE_FIX_CI_TIMEOUT: int = int(os.getenv("CODE_FIX_CI_TIMEOUT", "300"))`
   - Maximum seconds to wait for CI pipeline completion.

Place these AFTER the existing GitHub Integration section, using the same pattern of optional env vars with sensible defaults.
  </action>
  <verify>
Run `python -c "from src.config import Config; print('Config import OK')"` -- note this will fail due to missing required env vars, which is expected. Instead verify by reading the file and confirming the 5 new fields exist with correct defaults.
  </verify>
  <done>Config class has 5 new optional fields for Phase 5: ANTHROPIC_CODE_FIX_MODEL (default claude-sonnet-4-5-20250929), CODE_FIX_MAX_ROUNDS (3), CODE_FIX_MAX_TOKENS (4096), CODE_FIX_MAX_FILES (15), CODE_FIX_CI_TIMEOUT (300).</done>
</task>

</tasks>

<verification>
1. `python -c "from src.services.github_service import GitHubService"` succeeds without errors
2. The three new methods exist on GitHubService: `commit_files_atomic`, `poll_ci_status`, `get_installation_token`
3. Config has all 5 new fields with correct default values
4. No existing methods or behavior in github_service.py or config.py are broken
</verification>

<success_criteria>
GitHubService is extended with atomic multi-file commit (Git Data API), CI status polling (Checks API), and installation token extraction. Config exposes all Phase 5 tuning parameters with sensible defaults. Both files remain importable and backward-compatible with existing Phase 3 code.
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-code-fix-agentic-multi-step-code-generation-im-draft-fix-flow/05-01-SUMMARY.md`
</output>
