---
phase: 01-foundation-and-ingestion
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/cogs/webhook.py
  - src/cogs/bug_reports.py
  - src/views/bug_buttons.py
  - src/bot.py
autonomous: false
requirements:
  - FOUND-01
  - FOUND-02
  - FOUND-03
  - FOUND-04
  - FOUND-06
  - FOUND-08

must_haves:
  truths:
    - "A webhook POST with valid HMAC signature to /webhook/bug-report stores the bug and returns 200 within milliseconds"
    - "A webhook POST with invalid signature is rejected with 401"
    - "After webhook receipt, a summary embed appears in the configured Discord channel with hash ID, title, status, severity, and reporter"
    - "A thread is auto-created from the embed message with full bug details as the first message"
    - "Four action buttons appear on the embed: Dismiss (active), Analyze/Create Issue/Draft Fix (disabled)"
    - "Clicking Dismiss updates the bug status to dismissed and changes the embed to grey color"
    - "Buttons still work after the bot is restarted"
    - "Role gating prevents non-Developer users from clicking buttons"
  artifacts:
    - path: "src/cogs/webhook.py"
      provides: "aiohttp webhook server as Cog with HMAC validation and store-then-process"
      min_lines: 60
    - path: "src/cogs/bug_reports.py"
      provides: "Bug processing queue, embed posting, thread creation"
      min_lines: 80
    - path: "src/views/bug_buttons.py"
      provides: "DynamicItem BugActionButton with role gating, dismiss handler, persistent registration"
      min_lines: 80
  key_links:
    - from: "src/cogs/webhook.py"
      to: "src/utils/webhook_auth.py"
      via: "calls validate_webhook_signature"
      pattern: "validate_webhook_signature"
    - from: "src/cogs/webhook.py"
      to: "src/models/bug.py"
      via: "calls store_raw_report then queues bug_id"
      pattern: "store_raw_report"
    - from: "src/cogs/bug_reports.py"
      to: "src/utils/embeds.py"
      via: "calls build_summary_embed and build_thread_detail_message"
      pattern: "build_summary_embed|build_thread_detail_message"
    - from: "src/cogs/bug_reports.py"
      to: "src/models/bug.py"
      via: "calls get_bug, update_message_refs"
      pattern: "get_bug|update_message_refs"
    - from: "src/views/bug_buttons.py"
      to: "src/models/bug.py"
      via: "calls update_status, mark_dismissed, get_bug for dismiss handler"
      pattern: "mark_dismissed|update_status"
    - from: "src/bot.py"
      to: "src/views/bug_buttons.py"
      via: "registers DynamicItem in setup_hook"
      pattern: "add_dynamic_items"
---

<objective>
Build the complete ingestion-to-display pipeline: webhook server receives Supabase bug reports, validates HMAC, stores them, processes them asynchronously, and posts rich Discord embeds with threads and interactive buttons.

Purpose: This is the core functionality of Phase 1 -- turning webhook data into organized, interactive Discord content with persistent buttons.
Output: A fully functional bot that receives webhooks, displays bug reports as embeds with threads, and has working Dismiss buttons with role gating.
</objective>

<execution_context>
@C:/Users/silas/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/silas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-ingestion/01-CONTEXT.md
@.planning/phases/01-foundation-and-ingestion/01-RESEARCH.md
@.planning/phases/01-foundation-and-ingestion/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create webhook server cog and bug processing cog</name>
  <files>
    src/cogs/webhook.py
    src/cogs/bug_reports.py
  </files>
  <action>
**webhook.py -- WebhookServer Cog:**

Create a `commands.Cog` subclass that runs an aiohttp web server alongside the bot:

`cog_load()`:
- Create aiohttp `web.Application` with routes:
  - POST `/webhook/bug-report` -> `handle_webhook`
  - GET `/health` -> returns `{"status": "ok"}`
- Use `web.AppRunner` + `web.TCPSite` to start on `config.WEBHOOK_HOST:config.WEBHOOK_PORT`
- Log the listening address on startup

`cog_unload()`:
- Stop the TCPSite and cleanup the AppRunner gracefully

`handle_webhook(request)`:
- Read raw body bytes
- Validate HMAC signature using `validate_webhook_signature()` from `src/utils/webhook_auth.py`. Get the signature from the header named in `config.SIGNATURE_HEADER_NAME`. If missing or invalid, return 401.
- Parse JSON body. If JSON parse fails, return 400 with error message.
- Call `bot.bug_repo.store_raw_report(payload)` to immediately persist (store-then-process per FOUND-08). This returns the hash_id.
- Put the hash_id onto `bot.processing_queue`
- Return 200 with `{"status": "received", "bug_id": hash_id}` immediately -- do NOT wait for Discord posting
- Wrap in try/except: if store fails, return 500 with error. Never crash the server.

`health_check(request)`:
- Return 200 with `{"status": "ok", "queue_size": bot.processing_queue.qsize()}`

**bug_reports.py -- BugReports Cog:**

Create a `commands.Cog` that processes the queue and posts to Discord:

`cog_load()`:
- Create `self.process_task = self.bot.loop.create_task(self.process_loop())`

`cog_unload()`:
- Cancel the process_task

`process_loop()`:
- `await self.bot.wait_until_ready()` first
- Infinite loop: `bug_id = await self.bot.processing_queue.get()`
- Call `self.process_bug_report(bug_id)` in try/except
- On exception: log error, mark as failed in DB (update status or add an error field -- at minimum log it). Call `self.bot.processing_queue.task_done()` in finally block.

`process_bug_report(hash_id: str)`:
1. Fetch bug from DB: `self.bot.bug_repo.get_bug(hash_id)`
2. Get the configured channel: `self.bot.get_channel(config.BUG_CHANNEL_ID)`. If channel not found, log error and return.
3. Build summary embed using `build_summary_embed(bug)`
4. Build button view using `build_bug_view(hash_id)` from `src/views/bug_buttons.py`
5. Send embed + view to channel: `message = await channel.send(embed=embed, view=view)`
6. Create thread from the message using `message.create_thread()`:
   - Name: `get_thread_name(hash_id, bug.get('title'))`
   - Auto-archive duration: `get_auto_archive_duration(channel.guild)`
7. Post full details in thread: `await thread.send(build_thread_detail_message(bug))`
8. Update DB with message/thread refs: `bug_repo.update_message_refs(hash_id, message.id, thread.id, channel.id)`
9. Log success: "Bug #{hash_id} posted to #{channel.name} with thread"

Handle edge cases:
- If channel is None (bot lost access or bad config), log error
- If thread creation fails (permissions), log error but don't fail -- embed is still posted
- If detail message exceeds 2000 chars, split into multiple messages (but the embed builder should already truncate)

**Wire into bot.py:**
Update `src/bot.py` `setup_hook` to:
1. Load these cogs: `await self.load_extension("src.cogs.webhook")` and `await self.load_extension("src.cogs.bug_reports")`
2. Create `self.bug_repo = BugRepository(self.db)` after database setup
3. The processing_queue is already initialized in `__init__`

IMPORTANT: For cog extensions, use the correct Python module path. Since the bot runs from the project root, extensions should be loaded as `"src.cogs.webhook"` and `"src.cogs.bug_reports"`. Add an `async def setup(bot)` function at the bottom of each cog file that does `await bot.add_cog(CogClassName(bot))`.
  </action>
  <verify>
1. Start the bot (it should connect to Discord and start the webhook server)
2. Test health endpoint: `curl http://localhost:8080/health` should return `{"status": "ok", "queue_size": 0}`
3. Test invalid signature: `curl -X POST http://localhost:8080/webhook/bug-report -H "Content-Type: application/json" -d '{"test": true}'` should return 401
4. Test valid webhook: compute HMAC-SHA256 of the body with the webhook secret and send with correct header -- should return 200 with bug_id
  </verify>
  <done>
Webhook server runs on configured port alongside Discord bot. Valid HMAC-signed POSTs are stored immediately (200 response in milliseconds) and queued for async processing. Invalid signatures are rejected with 401. Processing loop fetches bugs from queue, posts summary embeds to configured channel, creates threads with full details, and stores Discord message/thread references in the database.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement DynamicItem buttons with role gating, dismiss handler, and persistent registration</name>
  <files>
    src/views/bug_buttons.py
    src/bot.py
  </files>
  <action>
**bug_buttons.py:**

Create the `BugActionButton` DynamicItem class following RESEARCH.md Pattern 2 exactly:

```python
class BugActionButton(
    discord.ui.DynamicItem[discord.ui.Button],
    template=r"bug:(?P<action>\w+):(?P<bug_id>[a-f0-9]+)"
):
```

`__init__(self, action: str, bug_id: str, *, disabled: bool = False)`:
- Define label_map: analyze="Analyze", create_issue="Create Issue", draft_fix="Draft Fix", dismiss="Dismiss"
- Define style_map: dismiss=danger (red), all others=primary (blurple). When disabled, use secondary (grey) style.
- Define emoji_map for visual distinction (Claude's discretion per CONTEXT.md): analyze="magnifying glass", create_issue="clipboard", draft_fix="wrench", dismiss="wastebasket" -- use Unicode emoji strings.
- Set custom_id format: `bug:{action}:{bug_id}` (well within 100-char limit)
- Store self.action and self.bug_id

`from_custom_id(cls, interaction, item, match)`:
- Extract action and bug_id from regex match groups
- Return cls(action, bug_id)

`interaction_check(self, interaction)`:
- Get the required role by name from config: `discord.utils.get(interaction.guild.roles, name=DEVELOPER_ROLE_NAME)`
- DEVELOPER_ROLE_NAME should come from bot config. Access via `interaction.client.config.developer_role_name`
- If role not found on server OR user doesn't have it: send ephemeral message "You need the {role_name} role to interact with bug reports." and return False
- Return True if user has the role

`callback(self, interaction)`:
- If action == "dismiss": handle dismiss flow
  1. Defer the response (ephemeral)
  2. Get bot reference: `interaction.client`
  3. Call `bot.bug_repo.mark_dismissed(self.bug_id, str(interaction.user))`
  4. If bug not found: send ephemeral "Bug not found"
  5. Rebuild the summary embed with updated (dismissed) status using `build_summary_embed(updated_bug)`
  6. Rebuild the view with `build_bug_view(self.bug_id, dismissed=True)` -- when dismissed, the Dismiss button should show as disabled too, all buttons disabled
  7. Edit the original message: `await interaction.message.edit(embed=new_embed, view=new_view)`
  8. Send confirmation in the thread (if thread exists): "Bug #{hash_id} dismissed by {user}"
  9. Send ephemeral followup: "Bug #{hash_id} has been dismissed."

- If action in ("analyze", "create_issue", "draft_fix"):
  - These should be disabled in the UI, but handle gracefully in case:
  - Send ephemeral: "The {action_label} feature is coming in a future update."

Create helper function `build_bug_view(bug_id: str, dismissed: bool = False) -> discord.ui.View`:
- Create `discord.ui.View(timeout=None)` -- timeout=None is CRITICAL for persistent views
- Add BugActionButton for each action: dismiss, analyze, create_issue, draft_fix
- If dismissed=True: all buttons disabled
- If not dismissed: dismiss is active/enabled, analyze/create_issue/draft_fix are disabled (Phase 2-3 features per CONTEXT.md)
- Return view

**Update bot.py setup_hook:**
Add `self.add_dynamic_items(BugActionButton)` -- this MUST happen in setup_hook before the bot connects, per RESEARCH.md pitfall 2. This is what makes buttons survive restarts (FOUND-06).

Import BugActionButton at the top of bot.py: `from src.views.bug_buttons import BugActionButton`
  </action>
  <verify>
1. Bot starts without errors and registers DynamicItem
2. Send a test webhook -- embed should appear with 4 buttons (Dismiss active, other 3 greyed out)
3. Click Dismiss with a user who has the Developer role -- embed should turn grey, all buttons disabled, confirmation in thread
4. Click Dismiss with a user who does NOT have the Developer role -- should get ephemeral "You need the Developer role..." message
5. Restart the bot -- click buttons on existing embeds -- they should still work (not "This interaction failed")
  </verify>
  <done>
DynamicItem BugActionButton handles all four action types. Dismiss updates bug status, refreshes embed to grey, disables all buttons, and posts confirmation in thread. Analyze/Create Issue/Draft Fix are shown but disabled with graceful fallback message. Role gating prevents unauthorized interaction. Buttons survive bot restarts via DynamicItem registration in setup_hook.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify end-to-end webhook-to-Discord flow</name>
  <files>no files modified -- verification only</files>
  <action>
Human verifies the complete Phase 1 bot: webhook ingestion with HMAC validation, summary embeds in Discord channel, per-bug threads with full details, interactive buttons with role gating, persistent buttons after restart, dismiss functionality, SQLite persistence.
  </action>
  <verify>
1. Ensure bot is running and connected to Discord (check console for "BugBot ready" or similar log)

2. Test webhook health:
   ```
   curl http://localhost:8080/health
   ```
   Expected: `{"status": "ok", "queue_size": 0}`

3. Send a test bug report (replace YOUR_SECRET with your WEBHOOK_SECRET):
   ```bash
   BODY='{"title":"App crashes on login","description":"The app crashes when clicking the login button after entering credentials","user_id":"user_123","device_info":"iPhone 14, iOS 17.2","app_version":"2.1.0","severity":"high","console_logs":"Error: Cannot read property of undefined\n  at LoginHandler.submit\n  at EventEmitter.emit","steps_to_reproduce":"1. Open app\n2. Enter email and password\n3. Click Login\n4. App crashes"}'
   SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "YOUR_SECRET" | cut -d' ' -f2)
   curl -X POST http://localhost:8080/webhook/bug-report \
     -H "Content-Type: application/json" \
     -H "X-Webhook-Signature: $SIGNATURE" \
     -d "$BODY"
   ```
   Expected: 200 response with `{"status": "received", "bug_id": "..."}`

4. Check Discord channel:
   - A summary embed should appear with: hash ID in title, status (red "Received"), severity "high", reporter "user_123"
   - Four buttons: Dismiss (active red), Analyze (greyed), Create Issue (greyed), Draft Fix (greyed)
   - A thread should be auto-created from the embed message

5. Open the thread:
   - First message should contain full bug details: title, description, device info, app version, console logs in code block, steps to reproduce

6. Test role gating:
   - Click Dismiss without the Developer role -- should get ephemeral rejection
   - Click Dismiss with the Developer role -- embed should turn grey, all buttons disabled, confirmation in thread

7. Test persistence:
   - Restart the bot (Ctrl+C then start again)
   - Send another test webhook
   - Verify the NEW bug's buttons work
   - Verify the OLD dismissed bug's buttons still respond (should show already-dismissed state)

8. Verify items to confirm:
   - Embed shows ONLY summary info (no console logs or device info in main channel)
   - Thread has full details
   - Hash ID is prominent in embed title
   - Colors match status (red for new, grey for dismissed)
  </verify>
  <done>
User has confirmed: webhook ingestion works, embeds display correctly with summary-only content, threads contain full details, buttons are functional with role gating, dismiss flow works, and buttons persist across bot restarts. Phase 1 is complete.
  </done>
</task>

</tasks>

<verification>
1. Webhook server accepts POST at /webhook/bug-report and validates HMAC signatures
2. Invalid signatures return 401, valid ones return 200 immediately
3. Bug reports appear as color-coded summary embeds in the configured Discord channel
4. Each embed has 4 buttons (Dismiss active, 3 disabled)
5. A thread is auto-created for each bug with full details
6. Dismiss changes embed to grey, disables all buttons, posts in thread
7. Role gating prevents non-Developer users from interacting
8. Buttons survive bot restart (DynamicItem persistence)
9. Raw webhook payloads are stored in SQLite before processing
10. Status changes are tracked in status_history table
</verification>

<success_criteria>
- End-to-end: webhook POST -> stored in DB -> embed in Discord -> thread with details -> buttons work
- Dismiss flow: button click -> status update -> embed refresh -> thread notification
- Persistence: restart bot -> buttons on old embeds still work
- Security: HMAC validation rejects bad signatures, role gating blocks unauthorized users
- Reliability: webhook returns 200 before processing (store-then-process)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-ingestion/01-02-SUMMARY.md`
</output>
