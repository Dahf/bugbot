---
phase: 01-foundation-and-ingestion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/bot.py
  - src/config.py
  - src/models/database.py
  - src/models/bug.py
  - src/utils/hashing.py
  - src/utils/webhook_auth.py
  - src/utils/embeds.py
  - requirements.txt
  - .env.example
  - .gitignore
autonomous: true
requirements:
  - FOUND-05
  - FOUND-07
  - FOUND-08

user_setup:
  - service: discord
    why: "Discord bot for receiving and displaying bug reports"
    env_vars:
      - name: DISCORD_TOKEN
        source: "Discord Developer Portal -> Applications -> Bot -> Token"
      - name: BUG_CHANNEL_ID
        source: "Discord -> Right-click target channel -> Copy Channel ID (enable Developer Mode in Settings -> Advanced)"
      - name: DEVELOPER_ROLE_NAME
        source: "Name of the Discord role that can interact with bug report buttons (default: Developer)"
    dashboard_config:
      - task: "Create a Discord Application and Bot"
        location: "https://discord.com/developers/applications -> New Application -> Bot tab -> Add Bot"
      - task: "Enable required intents: Server Members Intent (for role checking)"
        location: "Discord Developer Portal -> Applications -> Bot -> Privileged Gateway Intents"
      - task: "Generate invite URL with bot + applications.commands scopes and Send Messages, Create Public Threads, Embed Links, Read Message History, Use External Emojis permissions"
        location: "Discord Developer Portal -> Applications -> OAuth2 -> URL Generator"
  - service: supabase-webhook
    why: "Webhook secret for HMAC signature validation"
    env_vars:
      - name: WEBHOOK_SECRET
        source: "The shared secret used by your Supabase edge function to sign webhook payloads"
      - name: WEBHOOK_PORT
        source: "Port for the webhook HTTP server (default: 8080)"

must_haves:
  truths:
    - "Bot starts up and connects to Discord without errors"
    - "SQLite database is created with bugs and status_history tables on first run"
    - "Bug model can store and retrieve bug reports with all fields"
    - "Short hash IDs are generated uniquely for each bug"
    - "Configuration loads from environment variables with sensible defaults"
  artifacts:
    - path: "src/bot.py"
      provides: "BugBot class with setup_hook, main entry point"
      min_lines: 40
    - path: "src/config.py"
      provides: "Configuration from env vars"
      min_lines: 20
    - path: "src/models/database.py"
      provides: "Database connection setup with schema creation"
      contains: "CREATE TABLE IF NOT EXISTS bugs"
    - path: "src/models/bug.py"
      provides: "Bug CRUD operations (create, get, update status, list)"
      min_lines: 60
    - path: "src/utils/hashing.py"
      provides: "Short hash ID generation with collision checking"
      contains: "secrets.token_hex"
    - path: "src/utils/webhook_auth.py"
      provides: "HMAC-SHA256 webhook signature validation"
      contains: "hmac.compare_digest"
    - path: "src/utils/embeds.py"
      provides: "Embed builder helpers for summary and thread detail views"
      min_lines: 60
    - path: "requirements.txt"
      provides: "Python dependencies"
      contains: "discord.py"
  key_links:
    - from: "src/bot.py"
      to: "src/config.py"
      via: "imports Config class"
      pattern: "from config import"
    - from: "src/bot.py"
      to: "src/models/database.py"
      via: "calls setup_database in setup_hook"
      pattern: "setup_database"
    - from: "src/models/bug.py"
      to: "src/models/database.py"
      via: "uses aiosqlite connection"
      pattern: "aiosqlite"
---

<objective>
Set up the project foundation: directory structure, configuration, database schema with bug persistence, data models, and utility functions that all subsequent plans depend on.

Purpose: Every other plan in this phase needs the bot skeleton, database layer, and utility functions. This plan creates the shared foundation.
Output: A running (but empty) Discord bot with SQLite database, bug model, and all utility functions ready for use.
</objective>

<execution_context>
@C:/Users/silas/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/silas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-ingestion/01-CONTEXT.md
@.planning/phases/01-foundation-and-ingestion/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project skeleton with configuration and bot entry point</name>
  <files>
    src/bot.py
    src/config.py
    src/__init__.py
    src/cogs/__init__.py
    src/models/__init__.py
    src/views/__init__.py
    src/utils/__init__.py
    requirements.txt
    .env.example
    .gitignore
  </files>
  <action>
Create the project directory structure matching the architecture from RESEARCH.md:

```
src/
    __init__.py
    bot.py
    config.py
    cogs/__init__.py
    models/__init__.py
    views/__init__.py
    utils/__init__.py
requirements.txt
.env.example
.gitignore
```

**requirements.txt:**
```
discord.py>=2.6.0,<3.0.0
aiosqlite>=0.22.0,<1.0.0
python-dotenv>=1.0.0
```
Note: aiohttp ships with discord.py -- do not list it separately.

**config.py:**
Create a Config dataclass or class that loads from environment variables using python-dotenv:
- `DISCORD_TOKEN` (required, raise if missing)
- `BUG_CHANNEL_ID` (required, int -- the channel where bug embeds are posted)
- `WEBHOOK_SECRET` (required, raise if missing)
- `WEBHOOK_PORT` (int, default 8080)
- `WEBHOOK_HOST` (str, default "0.0.0.0")
- `DATABASE_PATH` (str, default "data/bugs.db")
- `DEVELOPER_ROLE_NAME` (str, default "Developer")
- `SIGNATURE_HEADER_NAME` (str, default "X-Webhook-Signature" -- configurable per RESEARCH.md open question)

Use `dotenv.load_dotenv()` at module level. Validate required fields in `__init__` or a `validate()` method.

**bot.py:**
Create the BugBot class subclassing `commands.Bot`:
- `__init__`: Set intents (default only -- do NOT enable message_content). Set command_prefix to "!" (unused but required by commands.Bot). Store a Config instance. Initialize `self.db = None` and `self.processing_queue = asyncio.Queue()`.
- `setup_hook`: Initialize database (call `setup_database`), load cog extensions (wrap in try/except for now since cogs don't exist yet -- log warning if cog not found). Register DynamicItems (placeholder comment for now).
- `on_ready`: Log bot name, guild count, and configured channel ID.
- `main()` function at module level: Create BugBot, call `bot.run(config.DISCORD_TOKEN)`.
- Create `data/` directory if it doesn't exist (for SQLite DB).

**.env.example:**
```
DISCORD_TOKEN=your_discord_bot_token
BUG_CHANNEL_ID=your_channel_id
WEBHOOK_SECRET=your_shared_secret
WEBHOOK_PORT=8080
DEVELOPER_ROLE_NAME=Developer
DATABASE_PATH=data/bugs.db
SIGNATURE_HEADER_NAME=X-Webhook-Signature
```

**.gitignore:**
Include: `__pycache__/`, `*.pyc`, `.env`, `data/`, `*.db`, `.venv/`, `venv/`, `.idea/`, `.vscode/`, `*.egg-info/`
  </action>
  <verify>
Run `cd C:/Users/silas/Desktop/preservefooddiscordbot && pip install -r requirements.txt` (in a venv if available). Then run `python -c "from src.config import Config; print('Config imported OK')"` and `python -c "from src.bot import BugBot; print('BugBot imported OK')"`. Both should print OK without errors.
  </verify>
  <done>
Project skeleton exists with all directories. Config loads environment variables with validation. BugBot class is importable and has setup_hook, on_ready. requirements.txt installs without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SQLite database schema and bug model with CRUD operations</name>
  <files>
    src/models/database.py
    src/models/bug.py
  </files>
  <action>
**database.py:**
Create `setup_database(db_path: str) -> aiosqlite.Connection` following RESEARCH.md schema exactly:

Schema must include:
- `bugs` table: id (INTEGER PK AUTOINCREMENT), hash_id (TEXT UNIQUE NOT NULL), status (TEXT NOT NULL DEFAULT 'received'), title (TEXT), description (TEXT), user_id (TEXT), device_info (TEXT), app_version (TEXT), console_logs (TEXT), steps_to_reproduce (TEXT), severity (TEXT), raw_payload (TEXT NOT NULL), message_id (INTEGER), thread_id (INTEGER), channel_id (INTEGER), created_at (TEXT NOT NULL), updated_at (TEXT NOT NULL), dismissed_at (TEXT), dismissed_by (TEXT)
- `status_history` table: id (INTEGER PK AUTOINCREMENT), bug_id (INTEGER NOT NULL REFERENCES bugs(id)), old_status (TEXT), new_status (TEXT NOT NULL), changed_by (TEXT), changed_at (TEXT NOT NULL)
- Indexes: idx_bugs_hash_id, idx_bugs_status, idx_bugs_message_id, idx_status_history_bug_id

Enable WAL mode: `PRAGMA journal_mode=WAL`
Enable foreign keys: `PRAGMA foreign_keys=ON`

Ensure the directory for db_path exists (create with `os.makedirs` if needed).

Also add `close_database(db: aiosqlite.Connection)` that commits and closes cleanly.

**bug.py:**
Create a `BugRepository` class that takes an `aiosqlite.Connection`:

Methods:
- `async create_bug(raw_payload: dict, hash_id: str) -> dict`: Insert a new bug from webhook payload. Extract fields from raw_payload with `.get()` defaulting to None for optional fields. Store raw_payload as JSON string. Set created_at and updated_at to current UTC ISO timestamp. Insert initial status_history entry (old_status=None, new_status='received'). Return the bug as a dict.
- `async get_bug(hash_id: str) -> dict | None`: Get a single bug by hash_id. Return None if not found.
- `async update_status(hash_id: str, new_status: str, changed_by: str | None = None) -> dict | None`: Update bug status. Validate new_status is one of: received, analyzing, triaged, issue_created, fix_drafted, resolved, dismissed. Insert status_history entry. Update updated_at. Return updated bug dict.
- `async update_message_refs(hash_id: str, message_id: int, thread_id: int, channel_id: int)`: Update Discord message/thread/channel references after posting.
- `async list_bugs(status: str | None = None, limit: int = 50) -> list[dict]`: List bugs, optionally filtered by status.
- `async mark_dismissed(hash_id: str, dismissed_by: str) -> dict | None`: Set status to 'dismissed', set dismissed_at and dismissed_by. Update embed styling info.
- `async get_status_history(hash_id: str) -> list[dict]`: Get full status history for a bug.
- `async store_raw_report(payload: dict) -> str`: The store-then-process entry point. Generate hash_id (using hashing utility), create the bug row with raw_payload, return hash_id. This is called immediately by the webhook handler before any processing.

Define valid statuses as a module-level constant:
```python
VALID_STATUSES = ("received", "analyzing", "triaged", "issue_created", "fix_drafted", "resolved", "dismissed")
```

Use `db.execute()` with parameterized queries (never string formatting) for all SQL operations. Use `db.row_factory = aiosqlite.Row` or convert rows to dicts manually.
  </action>
  <verify>
Create a quick test script that:
1. Calls `setup_database("data/test_bugs.db")`
2. Creates a BugRepository
3. Stores a raw report, retrieves it by hash_id
4. Updates its status to "analyzing"
5. Gets status history and confirms 2 entries (received + analyzing)
6. Cleans up test DB

Run with: `python -c "import asyncio; from src.models.database import setup_database; from src.models.bug import BugRepository; ... asyncio.run(test())"` or create a temporary test script. The test should complete without errors and print confirmation at each step.
  </verify>
  <done>
Database schema creates tables and indexes on startup. BugRepository supports all CRUD operations. store_raw_report creates a bug from raw webhook payload and returns hash_id. Status updates are tracked in status_history. All queries use parameterized SQL.
  </done>
</task>

<task type="auto">
  <name>Task 3: Build utility functions -- hash generation, HMAC auth, and embed builders</name>
  <files>
    src/utils/hashing.py
    src/utils/webhook_auth.py
    src/utils/embeds.py
  </files>
  <action>
**hashing.py:**
Create `async generate_hash_id(db: aiosqlite.Connection, length: int = 4) -> str`:
- Generate 8-character hex IDs using `secrets.token_hex(4)` (4 bytes = 8 hex chars per RESEARCH.md pitfall 7 recommendation -- NOT 4 chars, use 8 to avoid birthday problem collisions).
- Check for collision in DB: `SELECT 1 FROM bugs WHERE hash_id = ?`
- Retry up to 10 times. Raise RuntimeError if all attempts collide.
- Return the unique hash_id string.

**webhook_auth.py:**
Create `validate_webhook_signature(body: bytes, signature_header: str, secret: str) -> bool`:
- Compute HMAC-SHA256 of body using secret
- Use `hmac.compare_digest()` for timing-safe comparison (do NOT use `==`)
- Return True if signature matches
- Import from stdlib only: `hmac`, `hashlib`

**embeds.py:**
Create embed builder functions following CONTEXT.md locked decisions:

Define module-level constants:
```python
STATUS_COLORS = {
    "received": discord.Colour(0xED4245),      # Red
    "analyzing": discord.Colour(0x3498DB),      # Blue
    "triaged": discord.Colour(0xE67E22),        # Orange
    "issue_created": discord.Colour(0x9B59B6),  # Purple
    "fix_drafted": discord.Colour(0xF1C40F),    # Gold
    "resolved": discord.Colour(0x2ECC71),       # Green
    "dismissed": discord.Colour(0x95A5A6),      # Grey
}
```

Define STATUS_EMOJI dict matching (per RESEARCH.md code examples).

Functions:
1. `build_summary_embed(bug: dict) -> discord.Embed`:
   - Title: `#{hash_id} -- {title or 'Untitled Bug Report'}` (per CONTEXT.md: hash ID prominently in title)
   - Color: From STATUS_COLORS based on bug status
   - Fields (inline): Status (with emoji), Severity, Reporter
   - Footer: `Bug #{hash_id}`
   - Timestamp from bug's created_at
   - Per CONTEXT.md: Summary embed shows ONLY title, user, status, severity. NO console logs, device info, or steps in main channel embed.
   - For dismissed bugs: Use grey color. Add "[DISMISSED]" prefix to title per user decision on greyed/strikethrough styling (Discord embeds don't support strikethrough in titles, so use prefix + grey color + dimmed description).

2. `build_thread_detail_message(bug: dict) -> str`:
   - Format as a structured message (not an embed -- thread first message should be detailed text)
   - Include: Title, Description, Reporter, Device Info, App Version, Timestamp, Steps to Reproduce, Console Logs
   - Use "N/A" or "Unknown" for missing fields (per CONTEXT.md: never reject, fill gaps)
   - Truncate console_logs at 1500 chars with "... (truncated)" suffix
   - If total message exceeds 1900 chars (buffer under 2000 limit), truncate description and add note
   - Format console logs in a code block

3. `get_thread_name(hash_id: str, title: str | None) -> str`:
   - Format: `#{hash_id} -- {title or 'Untitled Bug Report'}`
   - Truncate to 100 chars (Discord thread name limit)

4. `get_auto_archive_duration(guild: discord.Guild) -> int`:
   - Check `guild.premium_tier`: tier >= 2 returns 10080, tier >= 1 returns 4320, else 1440
   - Per CONTEXT.md: user wants longest available. Per RESEARCH.md pitfall 1: max depends on boost level.
  </action>
  <verify>
Run: `python -c "from src.utils.hashing import generate_hash_id; print('hashing OK')"`, `python -c "from src.utils.webhook_auth import validate_webhook_signature; print('auth OK')"`, `python -c "from src.utils.embeds import build_summary_embed, build_thread_detail_message, STATUS_COLORS; print('embeds OK')"`. All three should import without errors. Additionally, test webhook_auth: create a known HMAC and verify it validates correctly.
  </verify>
  <done>
Hash generation produces 8-char hex IDs with collision checking. HMAC validation uses timing-safe comparison. Embed builder creates summary embeds with color-coded statuses (hash ID in title, only title/user/status/severity shown). Thread detail formatter includes all bug fields with N/A fallbacks and console log truncation. Thread name respects 100-char limit. Auto-archive duration adapts to server boost level.
  </done>
</task>

</tasks>

<verification>
1. All `src/` directories exist with `__init__.py` files
2. `pip install -r requirements.txt` completes without errors
3. Config loads from .env and validates required fields
4. Database creates tables on setup and BugRepository CRUD works end-to-end
5. Hash IDs are 8 hex characters and unique
6. HMAC validation correctly accepts valid and rejects invalid signatures
7. Summary embed includes only title, status, severity, reporter (not full details)
8. Thread detail message includes all fields with N/A fallbacks
</verification>

<success_criteria>
- Bot can be instantiated and configured from environment variables
- SQLite database creates schema with bugs + status_history tables
- Bug records can be created, read, updated (status), and listed
- Status changes are tracked in status_history
- Utility functions (hashing, HMAC auth, embed building) are importable and functional
- No blocking I/O -- all database operations use aiosqlite
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-ingestion/01-01-SUMMARY.md`
</output>
