---
phase: 02-ai-analysis
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/views/bug_buttons.py
  - src/cogs/ai_analysis.py
  - src/bot.py
autonomous: false
requirements: [AI-01, AI-03, AI-04, AI-07]
must_haves:
  truths:
    - "Clicking the Analyze button on a bug report triggers Claude AI analysis and posts a structured embed in the bug's Discord thread"
    - "A visible 'Analyzing bug report...' loading message appears in the thread and is edited in-place with the final analysis results"
    - "The original channel embed updates with triaged status and a priority badge (P1-P4) after analysis"
    - "If analysis is already in progress, a second click shows an ephemeral 'Analysis already in progress' message"
    - "If Claude API fails, the loading message is deleted, status reverts to received, and an ephemeral error is sent to the clicker"
    - "Token usage is displayed as footer text on the analysis embed"
    - "Thumbs-down reaction on analysis embeds is logged for quality tracking"
  artifacts:
    - path: "src/views/bug_buttons.py"
      provides: "Enabled Analyze button with full callback implementation"
      contains: "_handle_analyze"
    - path: "src/cogs/ai_analysis.py"
      provides: "AI analysis cog with reaction tracking and priority override"
      contains: "AIAnalysisCog"
    - path: "src/bot.py"
      provides: "AIAnalysisService initialization and cog loading"
      contains: "ai_service"
  key_links:
    - from: "src/views/bug_buttons.py"
      to: "src/services/ai_analysis.py"
      via: "bot.ai_service.analyze_bug(bug)"
      pattern: "ai_service\\.analyze_bug"
    - from: "src/views/bug_buttons.py"
      to: "src/utils/embeds.py"
      via: "build_analysis_embed for thread message"
      pattern: "build_analysis_embed"
    - from: "src/views/bug_buttons.py"
      to: "src/models/bug.py"
      via: "bug_repo.store_analysis and bug_repo.update_status"
      pattern: "store_analysis"
    - from: "src/cogs/ai_analysis.py"
      to: "on_raw_reaction_add"
      via: "thumbs-down reaction listener"
      pattern: "on_raw_reaction_add"
    - from: "src/bot.py"
      to: "src/services/ai_analysis.py"
      via: "AIAnalysisService instantiation with config"
      pattern: "AIAnalysisService"
---

<objective>
Wire the AI analysis service into Discord: enable the Analyze button, implement the full analysis flow (loading message -> API call -> edit with results -> update channel embed), add the AI analysis cog with reaction tracking and priority override, and update bot.py to initialize the AI service.

Purpose: Complete the user-facing AI analysis feature. After this plan, clicking Analyze on any bug report will trigger Claude analysis, post results in the thread, and update the channel embed with priority.

Output: Updated `src/views/bug_buttons.py` (enabled Analyze with full callback), new `src/cogs/ai_analysis.py` (reaction tracking, priority override), updated `src/bot.py` (AI service init, cog loading).
</objective>

<execution_context>
@C:/Users/silas/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/silas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ai-analysis/02-CONTEXT.md
@.planning/phases/02-ai-analysis/02-RESEARCH.md
@.planning/phases/02-ai-analysis/02-01-SUMMARY.md

# Key source files
@src/views/bug_buttons.py
@src/bot.py
@src/cogs/bug_reports.py
@src/services/ai_analysis.py
@src/utils/embeds.py
@src/models/bug.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable Analyze button and implement full analysis callback</name>
  <files>
    src/views/bug_buttons.py
  </files>
  <action>
**1. Update `build_bug_view` function** to enable the Analyze button conditionally:

Change the function signature to accept an `analyzed` parameter:
```python
def build_bug_view(bug_id: str, *, dismissed: bool = False, analyzed: bool = False) -> discord.ui.View:
```

The Analyze button should be:
- **Disabled** if `dismissed=True` (dismissed bugs cannot be analyzed)
- **Disabled** if `analyzed=True` (already analyzed -- one analysis per bug, per locked decision)
- **Enabled** otherwise (ready for analysis)

Create Issue and Draft Fix remain disabled (Phase 3).

**2. Add imports** at the top of `bug_buttons.py`:
```python
import anthropic
from src.utils.embeds import build_summary_embed, build_analysis_embed
```

**3. Implement `_handle_analyze` method** on `BugActionButton`:

This is the core analysis flow. Follow CONTEXT.md locked decisions precisely:

```python
async def _handle_analyze(self, interaction: discord.Interaction) -> None:
```

**Step-by-step flow:**

a) **Defer immediately** (within 3 seconds): `await interaction.response.defer(ephemeral=True)` -- this is ephemeral because the real content goes to the thread as a regular message visible to everyone.

b) **Fetch the bug** from DB: `bug = await bot.bug_repo.get_bug(self.bug_id)`
   - If bug is None: `await interaction.followup.send(f"Bug #{self.bug_id} not found.", ephemeral=True)` and return.

c) **Concurrent click guard** (per locked decision): Check bug status:
   - If `bug["status"] == "analyzing"`: `await interaction.followup.send("Analysis already in progress.", ephemeral=True)` and return.
   - If `bug["status"]` in `("triaged", "issue_created", "fix_drafted", "resolved")`: `await interaction.followup.send("This bug has already been analyzed.", ephemeral=True)` and return.
   - If `bug["status"] == "dismissed"`: `await interaction.followup.send("Cannot analyze a dismissed bug.", ephemeral=True)` and return.

d) **Check AI service availability**: `if bot.ai_service is None`: send ephemeral error "AI analysis is not configured. Set ANTHROPIC_API_KEY in environment." and return.

e) **Set status to "analyzing"**: `await bot.bug_repo.update_status(self.bug_id, "analyzing", str(interaction.user))`

f) **Update the channel embed** to show "analyzing" status: Rebuild the summary embed with the now-analyzing bug and edit the original message.
   ```python
   analyzing_bug = await bot.bug_repo.get_bug(self.bug_id)
   analyzing_embed = build_summary_embed(analyzing_bug)
   await interaction.message.edit(embed=analyzing_embed, view=build_bug_view(self.bug_id))
   ```

g) **Get the thread**: `thread = interaction.message.thread`
   - If thread is None AND `bug["thread_id"]` is not 0/None, try `thread = bot.get_channel(bug["thread_id"])` or `await bot.fetch_channel(bug["thread_id"])`
   - If thread is still None: revert status to "received", send ephemeral error "Could not find the bug thread. Please try again.", and return.

h) **Post loading message** in thread (visible to everyone, per locked decision):
   ```python
   loading_msg = await thread.send("Analyzing bug report... please wait.")
   ```

i) **Call AI service** (wrapped in try/except):
   ```python
   try:
       result = await bot.ai_service.analyze_bug(bug)
   except (anthropic.APIError, ValueError) as exc:
       # On failure: delete loading message, revert status, ephemeral error
       logger.error("AI analysis failed for bug %s: %s", self.bug_id, exc)
       await loading_msg.delete()
       await bot.bug_repo.update_status(self.bug_id, "received", "system")
       # Revert channel embed back to received
       reverted_bug = await bot.bug_repo.get_bug(self.bug_id)
       reverted_embed = build_summary_embed(reverted_bug)
       await interaction.message.edit(embed=reverted_embed, view=build_bug_view(self.bug_id))
       await interaction.followup.send(
           "AI analysis failed. Please try again later.", ephemeral=True
       )
       return
   ```

j) **Store analysis results** in DB:
   ```python
   updated_bug = await bot.bug_repo.store_analysis(self.bug_id, result, str(interaction.user))
   ```

k) **Build and post analysis embed** (edit loading message in-place, per locked decision):
   ```python
   analysis_embed = build_analysis_embed(updated_bug, result)
   await loading_msg.edit(content=None, embed=analysis_embed)
   ```

l) **Store the analysis message ID** for reaction tracking:
   ```python
   await bot.bug_repo.store_analysis_message_id(self.bug_id, loading_msg.id)
   ```

m) **Update the channel embed** with triaged status + priority badge:
   ```python
   summary_embed = build_summary_embed(updated_bug)
   new_view = build_bug_view(self.bug_id, analyzed=True)
   await interaction.message.edit(embed=summary_embed, view=new_view)
   ```

n) **Confirm to clicker** (ephemeral):
   ```python
   await interaction.followup.send(
       f"Analysis complete for bug #{self.bug_id}. Priority: **{result['priority']}**",
       ephemeral=True,
   )
   ```

**4. Update the `callback` method** to dispatch to `_handle_analyze`:
Replace the "analyze" branch in the `elif` from:
```python
elif self.action in ("analyze", "create_issue", "draft_fix"):
    label = _LABEL_MAP.get(self.action, self.action)
    await interaction.response.send_message(
        f"The **{label}** feature is coming in a future update.",
        ephemeral=True,
    )
```
to:
```python
elif self.action == "analyze":
    await self._handle_analyze(interaction)
elif self.action in ("create_issue", "draft_fix"):
    label = _LABEL_MAP.get(self.action, self.action)
    await interaction.response.send_message(
        f"The **{label}** feature is coming in a future update.",
        ephemeral=True,
    )
```
  </action>
  <verify>
- `python -c "from src.views.bug_buttons import BugActionButton, build_bug_view; v = build_bug_view('abc', analyzed=True); print('OK')"` succeeds
- `python -c "from src.views.bug_buttons import BugActionButton; assert hasattr(BugActionButton, '_handle_analyze')"` passes
- Review the callback dispatch to confirm "analyze" routes to `_handle_analyze` and "create_issue"/"draft_fix" still show "coming soon"
  </verify>
  <done>Analyze button is enabled for unanalyzed/undismissed bugs. Clicking it: defers interaction, guards against concurrent/duplicate clicks via status check, posts loading message in thread, calls AI service, edits loading message with analysis embed, stores results in DB, updates channel embed with status + priority badge. On failure: cleans up loading message, reverts status, sends ephemeral error.</done>
</task>

<task type="auto">
  <name>Task 2: Create AI analysis cog and wire everything into bot.py</name>
  <files>
    src/cogs/ai_analysis.py
    src/bot.py
  </files>
  <action>
**1. Create `src/cogs/ai_analysis.py`** -- a new Cog for AI analysis events:

```python
class AIAnalysisCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
```

**Reaction tracking** (per locked decision: thumbs-down to flag bad analysis, bot logs it):

Add a listener for `on_raw_reaction_add`:
```python
@commands.Cog.listener()
async def on_raw_reaction_add(self, payload: discord.RawReactionActionEvent):
```
- Check if the emoji is thumbs-down: `payload.emoji.name == "\U0001f44e"` (or the string name "thumbsdown")
- Ignore bot's own reactions: `if payload.user_id == self.bot.user.id: return`
- Look up if this message is an analysis embed by checking if `payload.message_id` matches any bug's `analysis_message_id` in the database. Add a helper method to BugRepository or query directly:
  ```python
  bug = await self.bot.bug_repo.get_bug_by_analysis_message(payload.message_id)
  ```
  Add `get_bug_by_analysis_message(self, message_id: int) -> dict | None` to `BugRepository` that does `SELECT * FROM bugs WHERE analysis_message_id = ?`.
- If a matching bug is found, log it:
  ```python
  logger.info(
      "Negative feedback on analysis for bug #%s by user %s",
      bug["hash_id"], payload.user_id,
  )
  ```
- This is lightweight logging only (per CONTEXT.md: "for long-term quality monitoring, not immediate action"). No database table for feedback in this phase.

**Priority override** (per CONTEXT.md: manual override supported, Claude's Discretion on UX):

Add a slash command for priority override (simpler and more discoverable than a select menu on every analysis message):
```python
@discord.app_commands.command(name="set-priority", description="Override a bug's priority score")
@discord.app_commands.describe(bug_id="The bug hash ID (e.g., a3f2b1c0)", priority="New priority level")
@discord.app_commands.choices(priority=[
    discord.app_commands.Choice(name="P1 - Critical", value="P1"),
    discord.app_commands.Choice(name="P2 - High", value="P2"),
    discord.app_commands.Choice(name="P3 - Medium", value="P3"),
    discord.app_commands.Choice(name="P4 - Low", value="P4"),
])
async def set_priority(self, interaction: discord.Interaction, bug_id: str, priority: discord.app_commands.Choice[str]):
```
- Validate role (same check as bug buttons -- user needs Developer role)
- Call `bot.bug_repo.update_priority(bug_id, priority.value, f"Manual override by {interaction.user}", str(interaction.user))`
- If bug not found, ephemeral error
- If bug found, update the channel embed (fetch the message via `bot.get_channel(bug["channel_id"])` then `channel.fetch_message(bug["message_id"])`, rebuild embed, edit)
- Also update the analysis embed in the thread if it exists (fetch via `analysis_message_id`, edit the priority field)
- Confirm ephemeral: `f"Priority for #{bug_id} updated to **{priority.value}**"`
- Log the override

**Setup function** for cog loading:
```python
async def setup(bot):
    await bot.add_cog(AIAnalysisCog(bot))
```

**2. Update `src/models/bug.py`** -- add `get_bug_by_analysis_message` method:
```python
async def get_bug_by_analysis_message(self, message_id: int) -> dict | None:
    async with self.db.execute(
        "SELECT * FROM bugs WHERE analysis_message_id = ?", (message_id,)
    ) as cursor:
        row = await cursor.fetchone()
        return _row_to_dict(row) if row else None
```

**3. Update `src/bot.py`:**

a) Add import: `from src.services.ai_analysis import AIAnalysisService`

b) In `BugBot.__init__`, add: `self.ai_service: AIAnalysisService | None = None`

c) In `setup_hook`, after the database initialization block, add AI service initialization:
```python
# Initialize AI analysis service (optional -- bot works without it)
if self.config.ANTHROPIC_API_KEY:
    self.ai_service = AIAnalysisService(
        api_key=self.config.ANTHROPIC_API_KEY,
        model=self.config.ANTHROPIC_MODEL,
        max_tokens=self.config.AI_MAX_TOKENS,
    )
    logger.info("AI analysis service initialized (model: %s)", self.config.ANTHROPIC_MODEL)
else:
    logger.warning("ANTHROPIC_API_KEY not set -- AI analysis disabled")
```

d) Add `"src.cogs.ai_analysis"` to the `cog_extensions` list.

e) After loading cogs, add app command sync:
```python
# Sync app commands (slash commands) with Discord
try:
    synced = await self.tree.sync()
    logger.info("Synced %d app command(s)", len(synced))
except Exception as exc:
    logger.error("Failed to sync app commands: %s", exc)
```
  </action>
  <verify>
- `python -c "from src.cogs.ai_analysis import AIAnalysisCog; print('OK')"` succeeds
- `python -c "from src.bot import BugBot; from src.config import Config; print('OK')"` imports without error
- `python -c "from src.models.bug import BugRepository; assert hasattr(BugRepository, 'get_bug_by_analysis_message')"` passes
- Review bot.py to confirm ai_service is initialized when ANTHROPIC_API_KEY is present and None when absent
- Review bot.py to confirm ai_analysis cog is in the extensions list
  </verify>
  <done>AIAnalysisCog is created with thumbs-down reaction tracking and /set-priority slash command for manual override. bot.py initializes AIAnalysisService conditionally (only if API key is set) and loads the new cog. BugRepository has get_bug_by_analysis_message for reaction tracking lookups.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify end-to-end AI analysis flow</name>
  <files>none (verification only)</files>
  <action>
Human verifies the complete AI analysis feature end-to-end.

What was built: Complete AI analysis feature -- Analyze button triggers Claude AI analysis, posts structured results in bug thread, updates channel embed with priority badge. Includes loading state, error handling, concurrent click protection, reaction tracking, and priority override command.

How to verify:
1. Ensure ANTHROPIC_API_KEY is set in your .env file
2. Start the bot: `python -m src.bot`
3. Send a test bug report via webhook (or use an existing one in the channel)
4. Click the **Analyze** button on a bug report embed
5. Verify:
   - An "Analyzing bug report... please wait." message appears in the bug's thread
   - After a few seconds, the message is replaced with a colour-coded analysis embed showing Root Cause, Affected Area, Severity, Priority (with reasoning), Suggested Fix, and token usage in the footer
   - The original channel embed updates to show "Triaged" status (orange) and a Priority field (e.g., P1, P2)
   - The Analyze button is now disabled (grey)
6. Click Analyze again on the same bug -- should get an ephemeral "This bug has already been analyzed" message
7. Try `/set-priority bug_id:<hash> priority:P1` to override the priority -- verify the channel embed updates
8. React with thumbs-down on the analysis embed -- check bot console for the feedback log line
  </action>
  <verify>All 8 verification steps above pass with expected behaviour</verify>
  <done>End-to-end AI analysis flow works: button click -> loading -> analysis embed in thread -> channel embed updated. Error handling, concurrency guards, priority override, and reaction tracking all functional.</done>
</task>

</tasks>

<verification>
- Bot starts without ANTHROPIC_API_KEY (AI analysis disabled, warning logged, other features work)
- Bot starts with ANTHROPIC_API_KEY (AI service initialized, Analyze button functional)
- Full analysis flow: click Analyze -> loading message -> AI call -> analysis embed in thread -> channel embed updated with priority
- Concurrent click protection: second click during analysis shows "already in progress"
- Duplicate prevention: clicking Analyze on already-analyzed bug shows "already been analyzed"
- Failure recovery: if API fails, loading message deleted, status reverted, ephemeral error sent
- Reaction tracking: thumbs-down on analysis embed logs feedback
- Priority override: /set-priority command updates priority in DB and refreshes embeds
</verification>

<success_criteria>
- Analyze button is enabled and functional on unanalyzed bug reports
- Clicking Analyze posts a loading message, calls Claude, and edits it with analysis results
- Analysis embed has colour-coded severity sidebar, all 5 content fields, and token usage footer
- Channel embed shows triaged status and priority badge after analysis
- Concurrent/duplicate click protection works via status guard
- API failure gracefully handled with cleanup
- /set-priority slash command allows manual priority override
- Thumbs-down reactions on analysis embeds are logged
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-analysis/02-02-SUMMARY.md`
</output>
