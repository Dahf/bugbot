---
phase: 03-github-integration
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/views/bug_buttons.py
  - src/services/github_service.py
  - src/models/bug.py
  - src/cogs/github_integration.py
  - src/cogs/webhook.py
autonomous: true
requirements: [GH-04, GH-05, GH-06, GH-07, GH-08, GH-10]

must_haves:
  truths:
    - "Clicking Draft Fix creates a feature branch from the default branch and opens a PR scaffold"
    - "The PR description includes bug context, AI analysis, Discord thread link, and Closes #N"
    - "The bot never commits to the default branch -- always creates feature branches"
    - "Re-triggering Draft Fix on a bug with an existing branch/PR is blocked with a link to the existing PR"
    - "GitHub webhook events (PR merged, closed) update the Discord embed status and post in the thread"
    - "When a PR is merged, the bug status automatically becomes resolved"
    - "Merged branches are cleaned up (deleted)"
  artifacts:
    - path: "src/views/bug_buttons.py"
      provides: "Enabled Draft Fix button with _handle_draft_fix callback"
      contains: "_handle_draft_fix"
    - path: "src/services/github_service.py"
      provides: "create_branch, create_pull_request, delete_branch methods"
      contains: "async_create_ref"
    - path: "src/models/bug.py"
      provides: "store_github_pr and get_bug_by_pr_url methods"
      contains: "github_pr_number"
    - path: "src/cogs/github_integration.py"
      provides: "GitHub webhook event handlers for PR merge/close/review_requested"
      contains: "handle_pr_merged"
    - path: "src/cogs/webhook.py"
      provides: "GitHub webhook route /webhook/github with signature verification"
      contains: "webhook/github"
  key_links:
    - from: "src/views/bug_buttons.py"
      to: "src/services/github_service.py"
      via: "bot.github_service.create_branch() and create_pull_request() in _handle_draft_fix"
      pattern: "create_branch|create_pull_request"
    - from: "src/cogs/webhook.py"
      to: "src/cogs/github_integration.py"
      via: "Webhook route dispatches parsed event to GitHubIntegration cog methods"
      pattern: "handle_github_event"
    - from: "src/cogs/github_integration.py"
      to: "src/models/bug.py"
      via: "Updates bug status to resolved on PR merge, updates embed"
      pattern: "update_status.*resolved"
    - from: "src/services/github_service.py"
      to: "githubkit.rest.git"
      via: "async_create_ref for branches, async_delete_ref for cleanup"
      pattern: "async_create_ref|async_delete_ref"
---

<objective>
Enable the Draft Fix button to create feature branches and PR scaffolds, add GitHub webhook handling for PR lifecycle events, and implement auto-resolve on merge with branch cleanup.

Purpose: Completes the full GitHub integration loop -- from bug report to PR to auto-resolution. The Draft Fix button closes the "report to reviewable code change" workflow, and webhook handlers close the "merge to resolved" feedback loop.
Output: Working Draft Fix button, GitHub webhook event processing, auto-resolve on PR merge, branch cleanup.
</objective>

<execution_context>
@C:/Users/silas/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/silas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-github-integration/03-RESEARCH.md
@.planning/phases/03-github-integration/03-01-SUMMARY.md
@.planning/phases/03-github-integration/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add branch and PR creation methods to GitHub service and enable Draft Fix button</name>
  <files>
    src/services/github_service.py
    src/views/bug_buttons.py
    src/models/bug.py
  </files>
  <action>
    **src/services/github_service.py:** Add these methods to `GitHubService`:

    - `async def get_default_branch_sha(self, gh, owner: str, repo: str) -> tuple[str, str]`:
      Get repo info: `(await gh.rest.repos.async_get(owner, repo)).parsed_data`.
      Get ref: `(await gh.rest.git.async_get_ref(owner, repo, f"heads/{default_branch}")).parsed_data`.
      Return `(default_branch, ref.object.sha)`.

    - `async def create_branch(self, owner: str, repo: str, branch_name: str, base_sha: str) -> None`:
      Get installation client. Call `gh.rest.git.async_create_ref(owner, repo, ref=f"refs/heads/{branch_name}", sha=base_sha)`.
      GH-08: This ALWAYS creates a new branch from the base SHA -- never touches the default branch.

    - `async def create_pull_request(self, owner: str, repo: str, title: str, body: str, head: str, base: str) -> dict`:
      Get installation client. Call `gh.rest.pulls.async_create(owner, repo, title=title, head=head, base=base, body=body)`.
      Return dict with `number`, `html_url`, `title` from parsed_data.

    - `async def delete_branch(self, owner: str, repo: str, branch_name: str) -> None`:
      Get installation client. Call `gh.rest.git.async_delete_ref(owner, repo, f"heads/{branch_name}")`.
      Catch 422/404 (branch already deleted or doesn't exist) silently.

    - `def build_branch_name(self, hash_id: str, title: str) -> str`:
      Static/utility method. Slugify the title: lowercase, replace non-alphanumeric with hyphens, collapse consecutive hyphens, strip leading/trailing hyphens, truncate to 30 chars.
      Return `f"bot/bug-{hash_id}-{slug}"`.
      Branch naming follows user decision: `bot/bug-{id}-{short-desc}`.

    **src/models/bug.py:** Add GitHub PR storage methods:

    - `async def store_github_pr(self, hash_id: str, pr_number: int, pr_url: str, branch_name: str, changed_by: str) -> dict | None`:
      Update bugs SET github_pr_number, github_pr_url, github_branch_name, status='fix_drafted', updated_at.
      Insert status_history (old_status -> 'fix_drafted'). Commit. Return updated bug.

    - `async def get_bug_by_github_issue(self, issue_number: int, repo_owner: str, repo_name: str) -> dict | None`:
      SELECT from bugs JOIN (need guild_id context... actually we can match on github_issue_number alone since it's unique per repo context). Use: `SELECT * FROM bugs WHERE github_issue_number = ?` -- if multiple bugs have the same issue number across different repos, this is unlikely but handle by returning first match.

    - `async def get_bug_by_branch_name(self, branch_name: str) -> dict | None`:
      `SELECT * FROM bugs WHERE github_branch_name = ?` -- for webhook PR event matching.

    **src/views/bug_buttons.py:** Implement `_handle_draft_fix`:

    1. `await interaction.response.defer(ephemeral=True)` -- 3-second rule.
    2. Fetch bug. Guard checks:
       - Bug not found -> error
       - `bug["status"] == "dismissed"` -> blocked
       - `bug["status"] not in ("issue_created", "triaged", "fix_drafted", "resolved")` -> "Create an issue first (click Create Issue)"
       - `bug.get("github_branch_name")` is not None -> "A fix branch already exists: {branch_name}. PR: {pr_url}" (per user decision: block re-trigger, show link to existing)
    3. Check bot.github_service and github_config_repo (same as create_issue guards).
    4. Get guild config for owner/repo.
    5. Build branch name: `bot.github_service.build_branch_name(bug['hash_id'], display_title)`.
    6. Get default branch SHA: `await bot.github_service.get_default_branch_sha(gh, owner, repo)`.
    7. Create branch: `await bot.github_service.create_branch(owner, repo, branch_name, base_sha)`.
       - Catch 422 (ref already exists): respond "Branch already exists. This bug may already have a draft fix." with link if available.
    8. Build PR body using `build_pr_body(bug, issue_number, discord_thread_url)`. Issue number comes from `bug.get("github_issue_number")`. If no issue exists, build PR body without `Closes #N`.
    9. Build PR title: `f"fix: {display_title} (#{bug['hash_id']})"`.
    10. Create PR: `await bot.github_service.create_pull_request(owner, repo, pr_title, pr_body, branch_name, default_branch)`.
    11. Store in DB: `await bot.bug_repo.store_github_pr(hash_id, pr.number, pr.url, branch_name, str(interaction.user))`.
    12. Update channel embed: rebuild summary embed (now shows fix_drafted + PR link). Update view.
    13. Post in thread: `f"Draft fix PR created: [{pr_title}]({pr_url})"`.
    14. Ephemeral followup with PR link.
    15. Error handling: wrap in try/except, on failure delete the created branch (cleanup partial state), log error, ephemeral error message.

    Update `callback` dispatch to route `draft_fix` to `_handle_draft_fix`.

    Update `build_bug_view` signature: add `issue_created: bool = False`, `fix_drafted: bool = False` parameters.
    - Create Issue: enabled when analyzed and NOT issue_created and NOT fix_drafted and NOT dismissed.
    - Draft Fix: enabled when issue_created and NOT fix_drafted and NOT dismissed. Also allow when triaged (no issue required) and NOT fix_drafted.
    - Actually, per the guard in _handle_draft_fix, Draft Fix should be available after analysis. So: enabled when (analyzed or issue_created) and NOT fix_drafted and NOT dismissed.

    Update ALL callers of `build_bug_view` in bug_buttons.py (the dismiss, analyze, create_issue, and draft_fix handlers) to pass the correct flags based on the updated bug state. Use a helper that inspects the bug dict to derive the flags: `dismissed = status == 'dismissed'`, `analyzed = status in ('triaged', 'issue_created', 'fix_drafted', 'resolved')`, `issue_created = github_issue_number is not None`, `fix_drafted = github_branch_name is not None`.
  </action>
  <verify>
    `python -c "from src.services.github_service import GitHubService; print('service OK')"` succeeds.
    `python -c "from src.views.bug_buttons import build_bug_view; v = build_bug_view('test', analyzed=True, issue_created=True); print('Draft Fix enabled:', not v.children[3].disabled)"` shows Draft Fix is enabled when issue_created.
    `python -c "from src.views.bug_buttons import build_bug_view; v = build_bug_view('test', analyzed=True, issue_created=True, fix_drafted=True); print('Draft Fix disabled:', v.children[3].disabled)"` shows Draft Fix is disabled when fix_drafted.
  </verify>
  <done>
    Draft Fix button creates a feature branch from the default branch (GH-08) and opens a PR scaffold (GH-04, GH-06) with full bug context and AI analysis in the PR body (GH-05, GH-07). Re-trigger is blocked with link to existing branch/PR. Discord embed updates to fix_drafted status with PR link.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add GitHub webhook route and PR lifecycle event handlers</name>
  <files>
    src/cogs/webhook.py
    src/cogs/github_integration.py
    src/models/bug.py
  </files>
  <action>
    **src/cogs/webhook.py:** Add a GitHub webhook route to the existing aiohttp server:

    1. Import `verify` from `githubkit.webhooks` at the top (conditional import -- wrap in try/except for when githubkit isn't installed).
    2. In `cog_load()`, add route: `app.router.add_post("/webhook/github", self.handle_github_webhook)`.
    3. Implement `handle_github_webhook(self, request)`:
       - Read raw body
       - Get `X-Hub-Signature-256` header
       - Get `GITHUB_WEBHOOK_SECRET` from bot.config. If not set, return 500 "GitHub webhook not configured".
       - Verify signature using `githubkit.webhooks.verify(secret, raw_body, signature)`. On failure return 401.
       - Get event name from `X-GitHub-Event` header
       - Parse body as JSON (don't use githubkit parse() here -- just JSON, since we need flexible event routing)
       - Dispatch to the GitHubIntegration cog: `github_cog = self.bot.get_cog("GitHubIntegration")`. If cog exists, call `await github_cog.handle_github_event(event_name, payload)`.
       - Return 200 `{"status": "ok"}`
       - IMPORTANT: Use a SEPARATE secret (GITHUB_WEBHOOK_SECRET) from the Supabase WEBHOOK_SECRET per Pitfall 5 in RESEARCH.md.

    **src/cogs/github_integration.py:** Add webhook event handler methods to `GitHubIntegration` cog:

    - `async def handle_github_event(self, event_name: str, payload: dict)`:
      Route by event_name:
      - `"pull_request"` -> `handle_pull_request_event(payload)`
      - `"installation"` -> log it (useful for debugging, /init polling handles the logic)
      - Ignore others with debug log.

    - `async def handle_pull_request_event(self, payload: dict)`:
      Extract action, PR number, PR html_url, head branch name, merged flag.
      Look up the bug by branch name: `bot.bug_repo.get_bug_by_branch_name(head_branch)`.
      If no matching bug found, log and return (PR not from our bot).

      Handle these actions:
      1. `action == "closed" and payload["pull_request"]["merged"]`:
         - PR merged -> auto-resolve the bug!
         - Update status to "resolved": `await bot.bug_repo.update_status(hash_id, "resolved", "github-webhook")`
         - Delete the branch: `await bot.github_service.delete_branch(owner, repo, branch_name)` (GH-10 branch cleanup)
         - Update Discord embed: fetch the channel message, rebuild embed with "resolved" status, edit it
         - Post in bug thread: "PR #{pr_number} has been merged! Bug resolved."
         - This implements: auto-resolve on merge, auto-delete branch on PR merge (user decisions)

      2. `action == "closed" and not merged`:
         - PR closed without merge
         - Post in bug thread: "PR #{pr_number} was closed without merging."
         - Do NOT change bug status (user might reopen or create new PR)

      3. `action == "review_requested"`:
         - Post in bug thread: "Review requested on PR #{pr_number}."

      For Discord embed/thread updates, the cog needs to:
      - Get the bug's channel_id and message_id from DB
      - Fetch the channel and message via bot
      - Rebuild embed using build_summary_embed with updated bug
      - Rebuild view using build_bug_view with correct flags
      - Edit the message

      Create a helper method `_update_discord_embed(self, bug: dict)` that encapsulates this pattern (fetch message, rebuild embed+view, edit). This will be reused across all webhook event handlers.

    **src/models/bug.py:** The `get_bug_by_branch_name` method was already added in Task 1. Ensure it's there. Also ensure `update_status` works for the "resolved" transition (it already does -- "resolved" is in VALID_STATUSES).

    IMPORTANT: Error handling for Discord operations in webhook handlers should be non-blocking -- if Discord edit fails (e.g., message was deleted), log the error but don't crash the webhook handler. Return 200 to GitHub regardless (they'll retry on non-2xx).
  </action>
  <verify>
    `python -c "from src.cogs.webhook import WebhookServer; print('webhook cog OK')"` succeeds.
    Verify that the webhook.py file contains both `/webhook/bug-report` and `/webhook/github` routes.
    `python -c "from src.cogs.github_integration import GitHubIntegration; print('github cog OK')"` succeeds.
    Verify that github_integration.py contains `handle_github_event`, `handle_pull_request_event`, and `_update_discord_embed` methods.
  </verify>
  <done>
    GitHub webhook endpoint receives and validates PR events (GH-10), auto-resolves bugs when their PR is merged with Discord embed/thread updates, cleans up merged branches (GH-10), and posts PR lifecycle notifications in bug threads.
  </done>
</task>

</tasks>

<verification>
- Draft Fix button creates a branch and PR scaffold when clicked on a triaged/issue_created bug
- PR body includes bug summary, AI analysis, Discord thread link, and Closes #N (when issue exists)
- Branch naming follows convention: bot/bug-{id}-{short-desc}
- Re-triggering Draft Fix on a bug with existing branch is blocked with helpful message
- No code path commits to the default branch (always feature branches)
- GitHub webhook endpoint at /webhook/github validates signatures with GITHUB_WEBHOOK_SECRET
- PR merge event triggers: bug resolved, embed updated, branch deleted, thread notification
- PR close (without merge) posts notification but doesn't change bug status
- All Discord operations in webhook handlers are non-blocking (errors logged, not raised)
- Bot starts successfully with and without GitHub configuration
</verification>

<success_criteria>
- Draft Fix creates branch + PR scaffold (GH-04, GH-06)
- PR uses repo context via bug analysis data (GH-05)
- PR description has bug context, analysis, Discord link, Closes #N (GH-07)
- Bot never commits to default branch (GH-08)
- GitHub webhook events update Discord (auto-resolve on merge)
- Merged branches are deleted (GH-10)
- Full workflow: bug -> analyze -> create issue -> draft fix -> PR merged -> auto-resolved
</success_criteria>

<output>
After completion, create `.planning/phases/03-github-integration/03-03-SUMMARY.md`
</output>
