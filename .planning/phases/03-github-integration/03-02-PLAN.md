---
phase: 03-github-integration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/cogs/github_integration.py
  - src/views/bug_buttons.py
  - src/models/bug.py
  - src/utils/embeds.py
  - src/bot.py
autonomous: true
requirements: [GH-01, GH-02, GH-03]

must_haves:
  truths:
    - "User can run /init in Discord to connect a GitHub repo to their server"
    - "/init provides an install link, polls for completion, and stores the repo config"
    - "Clicking Create Issue on a triaged bug creates a well-structured GitHub issue with labels"
    - "After issue creation, the Discord embed updates to show issue_created status and a link to the GitHub issue"
    - "A confirmation message with the issue link is posted in the bug's Discord thread"
  artifacts:
    - path: "src/cogs/github_integration.py"
      provides: "/init slash command with GitHub App install polling and repo selection"
      contains: "async_list_installations"
    - path: "src/views/bug_buttons.py"
      provides: "Enabled Create Issue button with full callback flow"
      contains: "_handle_create_issue"
    - path: "src/models/bug.py"
      provides: "store_github_issue method for persisting issue number and URL"
      contains: "github_issue_number"
    - path: "src/utils/embeds.py"
      provides: "Summary embed with GitHub issue link field when issue_created"
      contains: "GitHub Issue"
    - path: "src/bot.py"
      provides: "GitHubService and GitHubConfigRepository initialization, github_integration cog loading"
      contains: "github_service"
  key_links:
    - from: "src/views/bug_buttons.py"
      to: "src/services/github_service.py"
      via: "bot.github_service.create_issue() call in _handle_create_issue"
      pattern: "github_service.*create_issue"
    - from: "src/cogs/github_integration.py"
      to: "src/services/github_service.py"
      via: "bot.github_service.list_installations() in /init polling loop"
      pattern: "list_installations"
    - from: "src/views/bug_buttons.py"
      to: "src/models/bug.py"
      via: "bot.bug_repo.store_github_issue() after successful creation"
      pattern: "store_github_issue"
    - from: "src/bot.py"
      to: "src/services/github_service.py"
      via: "GitHubService initialization in setup_hook when github_configured"
      pattern: "GitHubService"
---

<objective>
Wire up the /init slash command for GitHub App setup and enable the Create Issue button to create well-structured GitHub issues from analyzed bug reports.

Purpose: This plan delivers the first visible GitHub integration -- users go from a connected repo (/init) to one-click issue creation (Create Issue button) with full context, labels, and bidirectional linking.
Output: Working /init command, enabled Create Issue button, GitHub issues with structured bodies and auto-created labels, Discord embeds updated with issue links.
</objective>

<execution_context>
@C:/Users/silas/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/silas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-github-integration/03-RESEARCH.md
@.planning/phases/03-github-integration/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /init slash command and wire GitHub service into bot</name>
  <files>
    src/cogs/github_integration.py
    src/bot.py
  </files>
  <action>
    **src/bot.py:** Add GitHub service initialization in `setup_hook()`:
    1. Import `GitHubService` from `src.services.github_service` and `GitHubConfigRepository` from `src.models.github_config`.
    2. Add `self.github_service: GitHubService | None = None` and `self.github_config_repo: GitHubConfigRepository | None = None` to `__init__`.
    3. In `setup_hook()`, after AI service init block, add a GitHub service init block:
       - If `self.config.github_configured`: create `GitHubService(app_id, private_key, client_id, client_secret)` and `GitHubConfigRepository(self.db)`. Log "GitHub integration initialized".
       - Else: log warning "GitHub App not configured -- GitHub integration disabled".
    4. Add `"src.cogs.github_integration"` to `cog_extensions` list.
    5. In `close()`, add `if self.github_service: await self.github_service.close()` before the DB close.

    **src/cogs/github_integration.py:** Create the GitHub integration cog:

    ```python
    class GitHubIntegration(commands.Cog):
    ```

    Implement `/init` slash command (app_commands.command):
    1. Check `bot.github_service is None` -> respond "GitHub integration not configured" (ephemeral).
    2. Check if guild already has a config (`bot.github_config_repo.get_config(interaction.guild_id)`):
       - If yes, show current repo info and ask if they want to reconfigure (ephemeral message with current `owner/repo`). For simplicity, proceed with reconfiguration flow if they triggered /init again.
    3. Defer the interaction (ephemeral=True) since the polling loop takes time.
    4. Build the GitHub App install URL: `https://github.com/apps/{bot.config.GITHUB_APP_NAME}/installations/new` and send it as a followup message (ephemeral) with a button-style link or plain text link: "Install the GitHub App on your repository: [link]. I'll wait up to 5 minutes for the installation..."
    5. Polling loop: every 5 seconds for up to 5 minutes (60 iterations):
       - Call `bot.github_service.list_installations()`
       - For each installation, check if it's new (compare against what we already know)
       - On new installation found: proceed to step 6
       - If timeout: send followup "Installation not detected within 5 minutes. Run /init again after installing the app."
    6. On installation detected:
       - Call `bot.github_service.list_installation_repos(installation.id)` to get accessible repos
       - If 0 repos: inform user the app needs repo access
       - If 1 repo: auto-select it
       - If multiple repos: present a `discord.ui.Select` dropdown (max 25 options) and await user selection (use a View with timeout)
    7. Store config: `bot.github_config_repo.set_config(guild_id, installation_id, owner, repo)`
    8. Send confirmation embed: "GitHub connected! Repository: owner/repo. You can now use Create Issue and Draft Fix buttons."

    Add the standard `async def setup(bot)` function at module bottom.

    IMPORTANT: The polling approach avoids needing a public callback URL for the setup flow (per RESEARCH.md recommendation). The aiohttp server IS publicly reachable (it already handles Supabase webhooks), but using polling for /init is simpler and avoids setup URL spoofing (Pitfall 3).
  </action>
  <verify>
    `python -c "from src.cogs.github_integration import GitHubIntegration; print('cog imports OK')"` succeeds.
    `python -c "from src.bot import BugBot; print('bot imports OK')"` succeeds.
    Verify that bot.py has github_service and github_config_repo attributes.
  </verify>
  <done>
    /init slash command exists with full polling-based GitHub App installation flow, bot.py initializes GitHubService and GitHubConfigRepository conditionally, and the github_integration cog is loaded.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enable Create Issue button with full issue creation flow</name>
  <files>
    src/views/bug_buttons.py
    src/services/github_service.py
    src/models/bug.py
  </files>
  <action>
    **src/services/github_service.py:** Add issue creation methods to `GitHubService`:

    - `async def ensure_labels(self, gh: GitHub, owner: str, repo: str, labels: list[tuple[str, str]]) -> None`:
      For each (name, color) tuple, try `await gh.rest.issues.async_create_label(owner, repo, name=name, color=color)`. Catch any exception (422 means label exists -- that's fine). This handles the "auto-create missing labels" user decision.

    - `async def create_issue(self, owner: str, repo: str, title: str, body: str, labels: list[str]) -> dict`:
      Get installation client via `get_installation_client(owner, repo)`.
      Call `gh.rest.issues.async_create(owner, repo, title=title, body=body, labels=labels)`.
      Return a dict with `number`, `html_url`, `title` from `resp.parsed_data`.

    **src/models/bug.py:** Add GitHub issue storage method to `BugRepository`:

    - `async def store_github_issue(self, hash_id: str, issue_number: int, issue_url: str, changed_by: str) -> dict | None`:
      Update bugs SET github_issue_number, github_issue_url, status='issue_created', updated_at.
      Insert status_history entry (old_status -> 'issue_created').
      Commit and return updated bug dict.
      Same pattern as `store_analysis()`.

    **src/views/bug_buttons.py:** Implement `_handle_create_issue`:

    1. `await interaction.response.defer(ephemeral=True)` -- must respond within 3 seconds (Pitfall 2).
    2. Fetch bug from DB. Guard checks:
       - Bug not found -> ephemeral error
       - `bug["status"] == "dismissed"` -> "Cannot create issue for a dismissed bug"
       - `bug["status"] not in ("triaged", "issue_created", "fix_drafted", "resolved")` -> "Bug must be analyzed first. Click Analyze before creating an issue."
       - `bug.get("github_issue_number")` is not None -> "Issue already exists: {url}" (prevent duplicate issues)
    3. Check `bot.github_service is None` -> "GitHub integration not configured"
    4. Get guild config: `bot.github_config_repo.get_config(interaction.guild_id)`. If None -> "No GitHub repo connected. Run /init first."
    5. Build issue title: `f"[Bug #{bug['hash_id']}] {display_title}"` (use `_get_display_title` helper from embeds or inline equivalent).
    6. Build labels list using `get_priority_label()`, `get_area_label()`, `get_bot_label()` from github_templates. Filter None values.
    7. Ensure labels exist: `await bot.github_service.ensure_labels(gh, owner, repo, label_tuples)`
    8. Build issue body: `build_issue_body(bug, guild_id=interaction.guild_id)`
    9. Create the issue: `await bot.github_service.create_issue(owner, repo, title, body, label_names)`
    10. Store in DB: `await bot.bug_repo.store_github_issue(hash_id, issue.number, issue.url, str(interaction.user))`
    11. Update channel embed: rebuild summary embed with updated bug (now shows issue_created status), rebuild view with issue_created=True.
    12. Post in thread: `f"GitHub issue created: [{title}]({url})"`
    13. Ephemeral followup: `f"Issue created: {url}"`
    14. Error handling: wrap GitHub API calls in try/except, log errors, send ephemeral "Failed to create issue. Please try again." on failure. Do NOT revert status on failure (issue might have been partially created).

    Update the `callback` dispatch in BugActionButton to route `create_issue` to `_handle_create_issue` instead of the "coming soon" placeholder.

    Update `build_bug_view` to accept `issue_created: bool = False` parameter. When `issue_created` is True OR `analyzed` is True, the Create Issue button should be enabled (blurple) UNLESS issue_created is True (then disable it -- issue already exists). The logic: Create Issue is enabled when the bug has been analyzed but no issue yet. Draft Fix remains disabled for now.

    IMPORTANT: Add import for github_templates functions at the top of bug_buttons.py. Handle the case where github_service is not available (bot started without GitHub config) gracefully.
  </action>
  <verify>
    `python -c "from src.views.bug_buttons import build_bug_view; v = build_bug_view('test123', analyzed=True); print(f'{len(v.children)} buttons'); print('Create Issue enabled:', not v.children[2].disabled)"` shows Create Issue is enabled when analyzed=True.
    `python -c "from src.views.bug_buttons import build_bug_view; v = build_bug_view('test123', analyzed=True, issue_created=True); print('Create Issue disabled:', v.children[2].disabled)"` shows Create Issue is disabled when issue_created=True.
  </verify>
  <done>
    Create Issue button is enabled for triaged bugs, creates a well-structured GitHub issue with auto-created labels (GH-01, GH-02), the issue body includes a Discord thread link (GH-03), the bug embed updates to show issue_created status with a link, and a confirmation is posted in the bug thread.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add GitHub issue link to summary embed and update embed refresh logic</name>
  <files>
    src/utils/embeds.py
  </files>
  <action>
    **src/utils/embeds.py:** Update `build_summary_embed` to show GitHub links:

    1. After the Priority field block, add a GitHub Issue field:
       - If `bug.get("github_issue_url")` is truthy, add field: name="GitHub Issue", value=`f"[#{bug['github_issue_number']}]({bug['github_issue_url']})"`, inline=True.
    2. After that, add a GitHub PR field:
       - If `bug.get("github_pr_url")` is truthy, add field: name="Pull Request", value=`f"[PR #{bug['github_pr_number']}]({bug['github_pr_url']})"`, inline=True.
       - This prepares the embed for Plan 03 (Draft Fix) without needing to modify embeds.py again.
    3. No other changes to embeds.py. The existing STATUS_COLORS already has entries for "issue_created" (purple) and "fix_drafted" (gold) so those will work automatically when status transitions happen.

    This task is small but important to keep separate because embeds.py is shared across many code paths and changes need to be precise to avoid breaking existing embed rendering.
  </action>
  <verify>
    `python -c "from src.utils.embeds import build_summary_embed; e = build_summary_embed({'hash_id': 'abc12345', 'status': 'issue_created', 'title': 'Test', 'github_issue_number': 42, 'github_issue_url': 'https://github.com/test/repo/issues/42'}); fields = [f.name for f in e.fields]; print('GitHub Issue field:', 'GitHub Issue' in fields)"` shows the field is present.
    `python -c "from src.utils.embeds import build_summary_embed; e = build_summary_embed({'hash_id': 'abc12345', 'status': 'triaged', 'title': 'Test'}); fields = [f.name for f in e.fields]; print('No GitHub field:', 'GitHub Issue' not in fields)"` confirms field is absent when no issue exists.
  </verify>
  <done>
    Summary embed conditionally shows GitHub Issue and Pull Request links when they exist, supporting both issue_created and fix_drafted statuses.
  </done>
</task>

</tasks>

<verification>
- Bot starts successfully with and without GitHub env vars
- /init command is registered and responds to Discord interactions
- Create Issue button is enabled on triaged bugs (was previously "coming soon")
- Create Issue button is disabled on received/analyzing bugs (need analysis first)
- Create Issue button is disabled after issue already created (prevent duplicates)
- GitHub issues include structured body with description, device info, AI analysis, console logs, and Discord thread link
- Labels are auto-created if missing in the repo
- Summary embed shows GitHub Issue link after issue creation
- Status transitions correctly: triaged -> issue_created
- Thread receives confirmation message with issue link
</verification>

<success_criteria>
- /init slash command works end-to-end: shows install link, polls, detects installation, stores config
- Create Issue button creates a GitHub issue with full context (GH-01, GH-02, GH-03)
- Issue body includes Discord thread link (GH-03)
- Labels auto-created with correct colors
- Discord embed updates to issue_created status with issue link
- Bug thread receives issue creation confirmation
- Bot gracefully handles: no GitHub config, no repo connected, already-created issue, API failures
</success_criteria>

<output>
After completion, create `.planning/phases/03-github-integration/03-02-SUMMARY.md`
</output>
