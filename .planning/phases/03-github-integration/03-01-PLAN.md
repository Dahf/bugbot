---
phase: 03-github-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config.py
  - src/models/database.py
  - src/models/github_config.py
  - src/services/github_service.py
  - src/utils/github_templates.py
  - requirements.txt
autonomous: true
requirements: [GH-09]

user_setup:
  - service: github-app
    why: "GitHub App provides fine-grained, auto-rotating installation tokens for repo operations"
    env_vars:
      - name: GITHUB_APP_ID
        source: "GitHub Developer Settings -> GitHub Apps -> your app -> App ID (numeric)"
      - name: GITHUB_PRIVATE_KEY
        source: "GitHub Developer Settings -> GitHub Apps -> your app -> Generate a private key (PEM). Base64-encode for Docker env var, or mount as file."
      - name: GITHUB_PRIVATE_KEY_FILE
        source: "Alternative to GITHUB_PRIVATE_KEY: mount the .pem file and set this to its path (e.g., /app/secrets/github-app.pem)"
      - name: GITHUB_CLIENT_ID
        source: "GitHub Developer Settings -> GitHub Apps -> your app -> Client ID"
      - name: GITHUB_CLIENT_SECRET
        source: "GitHub Developer Settings -> GitHub Apps -> your app -> Generate a new client secret"
      - name: GITHUB_WEBHOOK_SECRET
        source: "GitHub Developer Settings -> GitHub Apps -> your app -> Webhook secret (generate a random string, SEPARATE from WEBHOOK_SECRET)"
    dashboard_config:
      - task: "Create a GitHub App"
        location: "GitHub -> Settings -> Developer Settings -> GitHub Apps -> New GitHub App"
      - task: "Set permissions: Contents (Read & Write), Issues (Read & Write), Pull Requests (Read & Write), Metadata (Read-only)"
        location: "GitHub App settings -> Permissions & events"
      - task: "Subscribe to events: pull_request, installation, installation_repositories"
        location: "GitHub App settings -> Permissions & events -> Subscribe to events"
      - task: "Set Webhook URL to your bot's public URL + /webhook/github"
        location: "GitHub App settings -> General -> Webhook URL"
      - task: "Install the App on the target repository"
        location: "GitHub App settings -> Install App -> select repository"

must_haves:
  truths:
    - "GitHub API client authenticates as a GitHub App with auto-rotating installation tokens"
    - "Rate limits are handled automatically with retry and backoff on 429 and 5xx responses"
    - "Per-guild GitHub repo configuration can be stored and retrieved from SQLite"
    - "Issue and PR markdown templates produce well-structured bodies with all bug context"
  artifacts:
    - path: "src/config.py"
      provides: "GitHub App env var loading (GITHUB_APP_ID, GITHUB_PRIVATE_KEY, GITHUB_CLIENT_ID, GITHUB_CLIENT_SECRET, GITHUB_WEBHOOK_SECRET)"
      contains: "GITHUB_APP_ID"
    - path: "src/models/database.py"
      provides: "github_config table schema and migration for bugs table GitHub columns"
      contains: "github_config"
    - path: "src/models/github_config.py"
      provides: "GitHubConfigRepository CRUD for per-guild repo configuration"
      exports: ["GitHubConfigRepository"]
    - path: "src/services/github_service.py"
      provides: "GitHubService with App auth, installation client, and rate limit retry"
      exports: ["GitHubService"]
    - path: "src/utils/github_templates.py"
      provides: "Markdown template builders for issue body and PR body"
      exports: ["build_issue_body", "build_pr_body"]
    - path: "requirements.txt"
      provides: "githubkit[auth-app] dependency"
      contains: "githubkit"
  key_links:
    - from: "src/services/github_service.py"
      to: "githubkit.GitHub"
      via: "AppAuthStrategy with RetryChainDecision"
      pattern: "AppAuthStrategy"
    - from: "src/models/github_config.py"
      to: "src/models/database.py"
      via: "aiosqlite queries on github_config table"
      pattern: "github_config"
    - from: "src/utils/github_templates.py"
      to: "src/utils/embeds.py"
      via: "imports _parse_json_field and _format_device_info for consistent formatting"
      pattern: "_parse_json_field|_format_device_info"
---

<objective>
Build the GitHub integration foundation: configuration, database schema, GitHub App authentication service with rate limit handling, per-guild repo config storage, and markdown templates for issue/PR bodies.

Purpose: All subsequent plans (issue creation, PR scaffolding, webhook handlers) depend on this foundation layer. Getting auth, rate limits, and templates right first prevents rework.
Output: Working GitHubService that authenticates as a GitHub App, GitHubConfigRepository for per-guild settings, and template builders for issue/PR markdown bodies.
</objective>

<execution_context>
@C:/Users/silas/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/silas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-github-integration/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GitHub config, database schema, and per-guild config model</name>
  <files>
    src/config.py
    src/models/database.py
    src/models/github_config.py
    requirements.txt
  </files>
  <action>
    **requirements.txt:** Add `githubkit[auth-app]>=0.14.0,<1.0.0` to requirements.txt. Also add `aiohttp` to requirements.txt if not already listed (it's installed but not in requirements.txt -- the webhook cog depends on it).

    **src/config.py:** Add GitHub App env vars to the Config class. All are OPTIONAL (bot works without GitHub integration, same pattern as ANTHROPIC_API_KEY):
    - `GITHUB_APP_ID: str | None = os.getenv("GITHUB_APP_ID")`
    - `GITHUB_PRIVATE_KEY: str | None` -- load from `GITHUB_PRIVATE_KEY_FILE` (read file) first, fall back to `GITHUB_PRIVATE_KEY` env var (base64-decode if present). Both None = no GitHub integration. Import `base64` for decoding.
    - `GITHUB_CLIENT_ID: str | None = os.getenv("GITHUB_CLIENT_ID")`
    - `GITHUB_CLIENT_SECRET: str | None = os.getenv("GITHUB_CLIENT_SECRET")`
    - `GITHUB_WEBHOOK_SECRET: str | None = os.getenv("GITHUB_WEBHOOK_SECRET")`
    - `GITHUB_APP_NAME: str | None = os.getenv("GITHUB_APP_NAME")` -- used in /init to build the install URL
    - Add a property `github_configured: bool` that returns True only when APP_ID, PRIVATE_KEY, CLIENT_ID, and CLIENT_SECRET are all set (all four required for GitHub App auth).

    **src/models/database.py:** Add two things:
    1. Append to the SCHEMA string the `github_config` table:
       ```sql
       CREATE TABLE IF NOT EXISTS github_config (
           id INTEGER PRIMARY KEY AUTOINCREMENT,
           guild_id INTEGER UNIQUE NOT NULL,
           installation_id INTEGER NOT NULL,
           repo_owner TEXT NOT NULL,
           repo_name TEXT NOT NULL,
           created_at TEXT NOT NULL,
           updated_at TEXT NOT NULL
       );
       CREATE INDEX IF NOT EXISTS idx_github_config_guild ON github_config(guild_id);
       ```
    2. Add a `migrate_add_github_columns()` function (same idempotent pattern as `migrate_add_analysis_columns`) that adds these columns to `bugs` if missing:
       - `github_issue_number INTEGER`
       - `github_issue_url TEXT`
       - `github_pr_number INTEGER`
       - `github_pr_url TEXT`
       - `github_branch_name TEXT`
    3. Call `migrate_add_github_columns(db)` in `setup_database()` after the existing `migrate_add_analysis_columns(db)` call.

    **src/models/github_config.py:** Create a new `GitHubConfigRepository` class (same pattern as `BugRepository`):
    - `__init__(self, db: aiosqlite.Connection)` -- store db, set row_factory
    - `async def get_config(self, guild_id: int) -> dict | None` -- SELECT by guild_id
    - `async def set_config(self, guild_id: int, installation_id: int, repo_owner: str, repo_name: str) -> dict` -- INSERT OR REPLACE (upsert), return the stored config
    - `async def delete_config(self, guild_id: int) -> bool` -- DELETE, return True if row existed
    - Use `_utcnow_iso()` helper (import from bug.py or duplicate the 2-line function).
  </action>
  <verify>
    `python -c "from src.config import Config; from src.models.github_config import GitHubConfigRepository; from src.models.database import setup_database; print('imports OK')"` succeeds.
    `pip install -r requirements.txt` succeeds without errors.
  </verify>
  <done>
    Config loads GitHub env vars (all optional), database schema includes github_config table and bugs GitHub columns, GitHubConfigRepository provides CRUD for per-guild repo settings, and githubkit is installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GitHub service with App auth and markdown templates</name>
  <files>
    src/services/github_service.py
    src/utils/github_templates.py
  </files>
  <action>
    **src/services/github_service.py:** Create the `GitHubService` class:

    ```python
    from githubkit import GitHub, AppAuthStrategy
    from githubkit.retry import RetryChainDecision, RetryRateLimit, RetryServerError
    ```

    - `__init__(self, app_id: str, private_key: str, client_id: str, client_secret: str)`:
      - Create `self.app_github = GitHub(AppAuthStrategy(...), auto_retry=RetryChainDecision(RetryRateLimit(max_retry=3), RetryServerError(max_retry=2)))`
      - Store the app_github instance. This handles GH-09 (rate limits).

    - `async def get_installation_client(self, owner: str, repo: str) -> GitHub`:
      - Call `self.app_github.rest.apps.async_get_repo_installation(owner, repo)`
      - Return `self.app_github.with_auth(self.app_github.auth.as_installation(installation.id))`
      - This method is the gateway for ALL repo-scoped operations.

    - `async def list_installations(self) -> list`:
      - Call `self.app_github.rest.apps.async_list_installations()`
      - Return `resp.parsed_data` (list of installations for polling in /init)

    - `async def list_installation_repos(self, installation_id: int) -> list`:
      - Create installation-scoped client, then call `rest.apps.async_list_repos_accessible_to_installation()`
      - Return list of repo dicts with owner and name

    - `async def close(self)`:
      - Call `await self.app_github.aclose()` for clean shutdown

    **src/utils/github_templates.py:** Create template builder functions.

    Import `_parse_json_field` and `_format_device_info` from `src.utils.embeds` for consistent formatting.

    - `def build_issue_body(bug: dict) -> str`:
      Build a markdown string using the template from 03-RESEARCH.md Discretion Recommendations (Issue Template Format section). Include:
      - Bug Report header with hash_id
      - Description
      - Steps to Reproduce (or "Not provided")
      - Environment table: Device, App Version, Severity (reported)
      - AI Analysis section (if analyzed): Root Cause, Affected Area, AI Severity, Suggested Fix, Priority + reasoning
      - Console Logs in a collapsible `<details>` block
      - Discord Thread link: `https://discord.com/channels/{guild_id}/{thread_id}` (constructed from bug's channel_id and thread_id -- note: need guild_id as a parameter)
      - Footer: bot attribution line

    - `def build_pr_body(bug: dict, issue_number: int, discord_thread_url: str) -> str`:
      Build a PR markdown body including:
      - Bug summary (hash_id, title, description excerpt)
      - AI analysis summary (root cause, affected area, severity, suggested fix) if available
      - Discord Thread link
      - `Closes #{issue_number}` (auto-close on merge per user decision)
      - Note that this PR was scaffolded by the bot and may need code from an external tool (Copilot/BugBot)

    - `def build_discord_thread_url(guild_id: int, thread_id: int) -> str`:
      Return `f"https://discord.com/channels/{guild_id}/{thread_id}"`

    - `def get_priority_label(priority: str | None) -> tuple[str, str] | None`:
      Map priority string to (label_name, hex_color):
      P1 -> ("P1-critical", "e11d48"), P2 -> ("P2-high", "f97316"), P3 -> ("P3-medium", "eab308"), P4 -> ("P4-low", "22c55e"). Return None if priority is None or unrecognized.

    - `def get_area_label(area: str | None) -> tuple[str, str] | None`:
      If area is truthy, return (f"area:{area.lower().strip()}", "6366f1"). Otherwise None.

    - `def get_bot_label() -> tuple[str, str]`:
      Return ("bot-created", "8b5cf6").
  </action>
  <verify>
    `python -c "from src.services.github_service import GitHubService; from src.utils.github_templates import build_issue_body, build_pr_body, get_priority_label; print('imports OK')"` succeeds.
    Manually verify that `build_issue_body({'hash_id': 'abc12345', 'title': 'Test', 'description': 'Desc', 'status': 'triaged'}, guild_id=123)` returns a non-empty markdown string containing "Bug Report" and "abc12345".
  </verify>
  <done>
    GitHubService authenticates as a GitHub App with auto-retry for rate limits (GH-09), provides installation client method and installation listing for /init polling, and template builders produce well-structured markdown for GitHub issue and PR bodies.
  </done>
</task>

</tasks>

<verification>
- `pip install -r requirements.txt` succeeds and githubkit is installed
- All new modules import without errors
- Config.github_configured returns False when env vars are not set (bot starts fine)
- GitHubConfigRepository can be instantiated with a test database
- build_issue_body and build_pr_body return properly formatted markdown
- GitHubService constructor creates an authenticated GitHub client (no actual API call needed to verify -- just that initialization succeeds when given dummy credentials)
</verification>

<success_criteria>
- githubkit[auth-app] is in requirements.txt and installed
- Config class loads all GitHub env vars as optional
- Database schema includes github_config table and bugs table has 5 new GitHub columns
- GitHubConfigRepository provides get/set/delete for per-guild repo config
- GitHubService wraps githubkit with AppAuthStrategy and RetryChainDecision
- Issue and PR template builders produce complete markdown with all required sections
- No existing functionality is broken (bot starts without GitHub env vars)
</success_criteria>

<output>
After completion, create `.planning/phases/03-github-integration/03-01-SUMMARY.md`
</output>
